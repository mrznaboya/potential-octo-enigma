{"ast":null,"code":"function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nimport { EventEmitter } from '@unimodules/core';\nclass GeocoderError extends Error {\n  constructor() {\n    super('Geocoder service is not available for this device.');\n    this.code = 'E_NO_GEOCODER';\n  }\n}\nvar emitter = new EventEmitter({});\nfunction positionToJSON(position) {\n  if (!position) return null;\n  var {\n    coords = {},\n    timestamp\n  } = position;\n  return {\n    coords: {\n      latitude: coords.latitude,\n      longitude: coords.longitude,\n      altitude: coords.altitude,\n      accuracy: coords.accuracy,\n      altitudeAccuracy: coords.altitudeAccuracy,\n      heading: coords.heading,\n      speed: coords.speed\n    },\n    timestamp\n  };\n}\nexport default {\n  get name() {\n    return 'ExpoLocation';\n  },\n  getProviderStatusAsync() {\n    return _asyncToGenerator(function* () {\n      return {\n        locationServicesEnabled: 'geolocation' in navigator\n      };\n    })();\n  },\n  getCurrentPositionAsync(options) {\n    return _asyncToGenerator(function* () {\n      return new Promise((resolve, reject) => navigator.geolocation.getCurrentPosition(position => resolve(positionToJSON(position)), reject, options));\n    })();\n  },\n  removeWatchAsync(watchId) {\n    return _asyncToGenerator(function* () {\n      navigator.geolocation.clearWatch(watchId);\n    })();\n  },\n  watchDeviceHeading(headingId) {\n    return _asyncToGenerator(function* () {\n      console.warn('Location.watchDeviceHeading: is not supported on web');\n    })();\n  },\n  hasServicesEnabledAsync() {\n    return _asyncToGenerator(function* () {\n      return 'geolocation' in navigator;\n    })();\n  },\n  geocodeAsync() {\n    return _asyncToGenerator(function* () {\n      throw new GeocoderError();\n    })();\n  },\n  reverseGeocodeAsync() {\n    return _asyncToGenerator(function* () {\n      throw new GeocoderError();\n    })();\n  },\n  watchPositionImplAsync(watchId, options) {\n    return _asyncToGenerator(function* () {\n      return new Promise(resolve => {\n        watchId = global.navigator.geolocation.watchPosition(location => {\n          emitter.emit('Expo.locationChanged', {\n            watchId,\n            location: positionToJSON(location)\n          });\n        }, null, options);\n        resolve(watchId);\n      });\n    })();\n  },\n  requestPermissionsAsync() {\n    return _asyncToGenerator(function* () {\n      return new Promise(resolve => {\n        navigator.geolocation.getCurrentPosition(() => resolve({\n          status: 'granted'\n        }), _ref => {\n          var {\n            code\n          } = _ref;\n          if (code === 1) {\n            resolve({\n              status: 'denied'\n            });\n          } else {\n            resolve({\n              status: 'undetermined'\n            });\n          }\n        });\n      });\n    })();\n  }\n};","map":{"version":3,"names":["EventEmitter","GeocoderError","Error","constructor","code","emitter","positionToJSON","position","coords","timestamp","latitude","longitude","altitude","accuracy","altitudeAccuracy","heading","speed","name","getProviderStatusAsync","_asyncToGenerator","locationServicesEnabled","navigator","getCurrentPositionAsync","options","Promise","resolve","reject","geolocation","getCurrentPosition","removeWatchAsync","watchId","clearWatch","watchDeviceHeading","headingId","console","warn","hasServicesEnabledAsync","geocodeAsync","reverseGeocodeAsync","watchPositionImplAsync","global","watchPosition","location","emit","requestPermissionsAsync","status","_ref"],"sources":["/Users/zuyax/Developer/rn-starter/node_modules/expo-location/src/ExpoLocation.web.ts"],"sourcesContent":["import { EventEmitter } from '@unimodules/core';\n\ninterface Coordinates {\n  latitude: number;\n  longitude: number;\n  altitude?: number;\n  accuracy?: number;\n  altitudeAccuracy?: number;\n  heading?: number;\n  speed?: number;\n}\n\ninterface Position {\n  coords: Coordinates;\n  timestamp: number;\n}\n\ninterface PermissionResult {\n  status: string;\n}\n\nclass GeocoderError extends Error {\n  code: string;\n\n  constructor() {\n    super('Geocoder service is not available for this device.');\n    this.code = 'E_NO_GEOCODER';\n  }\n}\n\nconst emitter = new EventEmitter({} as any);\n\nfunction positionToJSON(position: any): Position | null {\n  if (!position) return null;\n\n  const { coords = {}, timestamp } = position;\n  return {\n    coords: {\n      latitude: coords.latitude,\n      longitude: coords.longitude,\n      altitude: coords.altitude,\n      accuracy: coords.accuracy,\n      altitudeAccuracy: coords.altitudeAccuracy,\n      heading: coords.heading,\n      speed: coords.speed,\n    },\n    timestamp,\n  };\n}\n\nexport default {\n  get name(): string {\n    return 'ExpoLocation';\n  },\n  async getProviderStatusAsync(): Promise<{ locationServicesEnabled: boolean }> {\n    return {\n      locationServicesEnabled: 'geolocation' in navigator,\n    };\n  },\n  async getCurrentPositionAsync(options: Object): Promise<Position | null> {\n    return new Promise<Position | null>((resolve, reject) =>\n      navigator.geolocation.getCurrentPosition(\n        position => resolve(positionToJSON(position)),\n        reject,\n        options\n      )\n    );\n  },\n  async removeWatchAsync(watchId): Promise<void> {\n    navigator.geolocation.clearWatch(watchId);\n  },\n  async watchDeviceHeading(headingId): Promise<void> {\n    console.warn('Location.watchDeviceHeading: is not supported on web');\n  },\n  async hasServicesEnabledAsync(): Promise<boolean> {\n    return 'geolocation' in navigator;\n  },\n  async geocodeAsync(): Promise<Array<any>> {\n    throw new GeocoderError();\n  },\n  async reverseGeocodeAsync(): Promise<Array<any>> {\n    throw new GeocoderError();\n  },\n  async watchPositionImplAsync(watchId: string, options: Object): Promise<string> {\n    return new Promise<string>(resolve => {\n      // @ts-ignore\n      watchId = global.navigator.geolocation.watchPosition(\n        location => {\n          emitter.emit('Expo.locationChanged', { watchId, location: positionToJSON(location) });\n        },\n        null,\n        options\n      );\n      resolve(watchId);\n    });\n  },\n  async requestPermissionsAsync(): Promise<PermissionResult> {\n    return new Promise<PermissionResult>(resolve => {\n      navigator.geolocation.getCurrentPosition(\n        () => resolve({ status: 'granted' }),\n        ({ code }) => {\n          if (code === 1 /* PERMISSION_DENIED */) {\n            resolve({ status: 'denied' });\n          } else {\n            resolve({ status: 'undetermined' });\n          }\n        }\n      );\n    });\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}