{"ast":null,"code":"function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport Constants from 'expo-constants';\nimport { Platform } from '@unimodules/core';\nimport path from 'path-browserify';\nimport PixelRatio from \"react-native-web/dist/exports/PixelRatio\";\nimport URL from 'url-parse';\nimport AssetSourceResolver from \"./AssetSourceResolver\";\nimport { getManifestBaseUrl } from \"./AssetUris\";\nvar assetMapOverride = Constants.manifest && Constants.manifest.assetMapOverride;\nvar manifestBaseUrl = Constants.experienceUrl ? getManifestBaseUrl(Constants.experienceUrl) : null;\nexport function selectAssetSource(meta) {\n  if (assetMapOverride && assetMapOverride.hasOwnProperty(meta.hash)) {\n    meta = _objectSpread({}, meta, {}, assetMapOverride[meta.hash]);\n  }\n  var scale = AssetSourceResolver.pickScale(meta.scales, PixelRatio.get());\n  var index = meta.scales.findIndex(s => s === scale);\n  var hash = meta.fileHashes ? meta.fileHashes[index] || meta.fileHashes[0] : meta.hash;\n  var uri = meta.fileUris ? meta.fileUris[index] || meta.fileUris[0] : meta.uri;\n  if (uri) {\n    return {\n      uri: resolveUri(uri),\n      hash\n    };\n  }\n  var assetUrlOverride = Constants.manifest && Constants.manifest.assetUrlOverride;\n  if (assetUrlOverride) {\n    var _uri = path.join(assetUrlOverride, hash);\n    return {\n      uri: resolveUri(_uri),\n      hash\n    };\n  }\n  var fileScale = scale === 1 ? '' : \"@\".concat(scale, \"x\");\n  var fileExtension = meta.type ? \".\".concat(encodeURIComponent(meta.type)) : '';\n  var suffix = \"/\".concat(encodeURIComponent(meta.name)).concat(fileScale).concat(fileExtension, \"?platform=\").concat(encodeURIComponent(Platform.OS), \"&hash=\").concat(encodeURIComponent(meta.hash));\n  if (/^https?:\\/\\//.test(meta.httpServerLocation)) {\n    var _uri2 = meta.httpServerLocation + suffix;\n    return {\n      uri: _uri2,\n      hash\n    };\n  }\n  if (Constants.manifest && Constants.manifest.developer) {\n    var baseUrl = new URL(Constants.manifest.bundleUrl);\n    baseUrl.set('pathname', meta.httpServerLocation + suffix);\n    return {\n      uri: baseUrl.href,\n      hash\n    };\n  }\n  return {\n    uri: \"https://d1wp6m56sqw74a.cloudfront.net/~assets/\".concat(encodeURIComponent(hash)),\n    hash\n  };\n}\nexport function resolveUri(uri) {\n  if (!manifestBaseUrl) {\n    return uri;\n  }\n  var {\n    protocol\n  } = new URL(uri);\n  if (protocol !== '') {\n    return uri;\n  }\n  var baseUrl = new URL(manifestBaseUrl);\n  var resolvedPath = uri.startsWith('/') ? uri : path.join(baseUrl.pathname, uri);\n  baseUrl.set('pathname', resolvedPath);\n  return baseUrl.href;\n}","map":{"version":3,"names":["Constants","Platform","path","PixelRatio","URL","AssetSourceResolver","getManifestBaseUrl","assetMapOverride","manifest","manifestBaseUrl","experienceUrl","selectAssetSource","meta","hasOwnProperty","hash","_objectSpread","scale","pickScale","scales","get","index","findIndex","s","fileHashes","uri","fileUris","resolveUri","assetUrlOverride","join","fileScale","concat","fileExtension","type","encodeURIComponent","suffix","name","OS","test","httpServerLocation","developer","baseUrl","bundleUrl","set","href","protocol","resolvedPath","startsWith","pathname"],"sources":["/Users/zuyax/Developer/rn-starter/node_modules/expo-asset/src/AssetSources.ts"],"sourcesContent":["import Constants from 'expo-constants';\nimport { Platform } from '@unimodules/core';\nimport path from 'path-browserify';\nimport { PixelRatio } from 'react-native';\nimport URL from 'url-parse';\nimport AssetSourceResolver from './AssetSourceResolver';\n\nimport { getManifestBaseUrl } from './AssetUris';\n\nexport type AssetMetadata = {\n  hash: string;\n  name: string;\n  type: string;\n  width?: number;\n  height?: number;\n  scales: number[];\n  httpServerLocation: string;\n  uri?: string;\n  fileHashes?: string[];\n  fileUris?: string[];\n};\n\nexport type AssetSource = {\n  uri: string;\n  hash: string;\n};\n\n// Fast lookup check if asset map has any overrides in the manifest\nconst assetMapOverride = Constants.manifest && Constants.manifest.assetMapOverride;\n\n// Compute manifest base URL if available\nconst manifestBaseUrl = Constants.experienceUrl\n  ? getManifestBaseUrl(Constants.experienceUrl)\n  : null;\n\n/**\n * Selects the best file for the given asset (ex: choosing the best scale for images) and returns\n * a { uri, hash } pair for the specific asset file.\n *\n * If the asset isn't an image with multiple scales, the first file is selected.\n */\nexport function selectAssetSource(meta: AssetMetadata): AssetSource {\n  // Override with the asset map in manifest if available\n  if (assetMapOverride && assetMapOverride.hasOwnProperty(meta.hash)) {\n    meta = { ...meta, ...assetMapOverride[meta.hash] };\n  }\n\n  // This logic is based on that of AssetSourceResolver, with additional support for file hashes and\n  // explicitly provided URIs\n  const scale = AssetSourceResolver.pickScale(meta.scales, PixelRatio.get());\n  const index = meta.scales.findIndex(s => s === scale);\n  const hash = meta.fileHashes ? meta.fileHashes[index] || meta.fileHashes[0] : meta.hash;\n\n  // Allow asset processors to directly provide the URL to load\n  const uri = meta.fileUris ? meta.fileUris[index] || meta.fileUris[0] : meta.uri;\n  if (uri) {\n    return { uri: resolveUri(uri), hash };\n  }\n\n  // Check if the assetUrl was overridden in the manifest\n  const assetUrlOverride = Constants.manifest && Constants.manifest.assetUrlOverride;\n  if (assetUrlOverride) {\n    const uri = path.join(assetUrlOverride, hash);\n    return { uri: resolveUri(uri), hash };\n  }\n\n  const fileScale = scale === 1 ? '' : `@${scale}x`;\n  const fileExtension = meta.type ? `.${encodeURIComponent(meta.type)}` : '';\n  const suffix = `/${encodeURIComponent(\n    meta.name\n  )}${fileScale}${fileExtension}?platform=${encodeURIComponent(\n    Platform.OS\n  )}&hash=${encodeURIComponent(meta.hash)}`;\n\n  // For assets with a specified absolute URL, we use the existing origin instead of prepending the\n  // development server or production CDN URL origin\n  if (/^https?:\\/\\//.test(meta.httpServerLocation)) {\n    const uri = meta.httpServerLocation + suffix;\n    return { uri, hash };\n  }\n\n  // For assets during development, we use the development server's URL origin\n  if (Constants.manifest && Constants.manifest.developer) {\n    const baseUrl = new URL(Constants.manifest.bundleUrl);\n    baseUrl.set('pathname', meta.httpServerLocation + suffix);\n    return { uri: baseUrl.href, hash };\n  }\n\n  // Production CDN URIs are based on each asset file hash\n  return {\n    uri: `https://d1wp6m56sqw74a.cloudfront.net/~assets/${encodeURIComponent(hash)}`,\n    hash,\n  };\n}\n\n/**\n * Resolves the given URI to an absolute URI. If the given URI is already an absolute URI, it is\n * simply returned. Otherwise, if it is a relative URI, it is resolved relative to the manifest's\n * base URI.\n */\nexport function resolveUri(uri: string): string {\n  if (!manifestBaseUrl) {\n    return uri;\n  }\n\n  const { protocol } = new URL(uri);\n  if (protocol !== '') {\n    return uri;\n  }\n\n  const baseUrl = new URL(manifestBaseUrl);\n  const resolvedPath = uri.startsWith('/') ? uri : path.join(baseUrl.pathname, uri);\n  baseUrl.set('pathname', resolvedPath);\n  return baseUrl.href;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}