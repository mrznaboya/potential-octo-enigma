{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/objectSpread\";\nimport shallowEqual from \"../utils/shallowEqual\";\nvar SCENE_KEY_PREFIX = 'scene_';\nfunction compareKey(one, two) {\n  var delta = one.length - two.length;\n  if (delta > 0) {\n    return 1;\n  }\n  if (delta < 0) {\n    return -1;\n  }\n  return one > two ? 1 : -1;\n}\nfunction compareScenes(one, two) {\n  if (one.index > two.index) {\n    return 1;\n  }\n  if (one.index < two.index) {\n    return -1;\n  }\n  return compareKey(one.key, two.key);\n}\nfunction areScenesShallowEqual(one, two) {\n  return one.key === two.key && one.index === two.index && one.isStale === two.isStale && one.isActive === two.isActive && areRoutesShallowEqual(one.route, two.route);\n}\nfunction areRoutesShallowEqual(one, two) {\n  if (!one || !two) {\n    return one === two;\n  }\n  if (one.key !== two.key) {\n    return false;\n  }\n  return shallowEqual(one, two);\n}\nexport default function ScenesReducer(scenes, nextState, prevState, descriptors) {\n  scenes.forEach(function (scene) {\n    var route = scene.route;\n    if (descriptors && descriptors[route.key]) {\n      scene.descriptor = descriptors[route.key];\n    }\n  });\n  if (prevState === nextState) {\n    return scenes;\n  }\n  var prevScenes = new Map();\n  var freshScenes = new Map();\n  var staleScenes = new Map();\n  scenes.forEach(function (scene) {\n    var key = scene.key;\n    if (scene.isStale) {\n      staleScenes.set(key, scene);\n    }\n    prevScenes.set(key, scene);\n  });\n  var nextKeys = new Set();\n  var nextRoutes = nextState.routes;\n  if (nextRoutes.length > nextState.index + 1) {\n    console.warn('StackRouter provided invalid state, index should always be the top route');\n    nextRoutes = nextState.routes.slice(0, nextState.index + 1);\n  }\n  nextRoutes.forEach(function (route, index) {\n    var key = SCENE_KEY_PREFIX + route.key;\n    var descriptor = descriptors && descriptors[route.key];\n    var scene = {\n      index: index,\n      isActive: false,\n      isStale: false,\n      key: key,\n      route: route,\n      descriptor: descriptor\n    };\n    if (nextKeys.has(key)) {\n      throw new Error(\"navigation.state.routes[\" + index + \"].key \\\"\" + key + \"\\\" conflicts with \" + 'another route!');\n    }\n    nextKeys.add(key);\n    if (staleScenes.has(key)) {\n      staleScenes.delete(key);\n    }\n    freshScenes.set(key, scene);\n  });\n  if (prevState) {\n    var prevRoutes = prevState.routes;\n    if (prevRoutes.length > prevState.index + 1) {\n      console.warn('StackRouter provided invalid state, index should always be the top route');\n      prevRoutes = prevRoutes.slice(0, prevState.index + 1);\n    }\n    prevRoutes.forEach(function (route, index) {\n      var key = SCENE_KEY_PREFIX + route.key;\n      if (freshScenes.has(key)) {\n        return;\n      }\n      var lastScene = scenes.find(function (scene) {\n        return scene.route.key === route.key;\n      });\n      var descriptor = lastScene ? lastScene.descriptor : descriptors[route.key];\n      if (descriptor) {\n        staleScenes.set(key, {\n          index: index,\n          isActive: false,\n          isStale: true,\n          key: key,\n          route: route,\n          descriptor: descriptor\n        });\n      }\n    });\n  }\n  var nextScenes = [];\n  var mergeScene = function mergeScene(nextScene) {\n    var key = nextScene.key;\n    var prevScene = prevScenes.has(key) ? prevScenes.get(key) : null;\n    if (prevScene && areScenesShallowEqual(prevScene, nextScene)) {\n      nextScenes.push(prevScene);\n    } else {\n      nextScenes.push(nextScene);\n    }\n  };\n  staleScenes.forEach(mergeScene);\n  freshScenes.forEach(mergeScene);\n  nextScenes.sort(compareScenes);\n  var activeScenesCount = 0;\n  nextScenes.forEach(function (scene, ii) {\n    var isActive = !scene.isStale && scene.index === nextState.index;\n    if (isActive !== scene.isActive) {\n      nextScenes[ii] = _objectSpread({}, scene, {\n        isActive: isActive\n      });\n    }\n    if (isActive) {\n      activeScenesCount++;\n    }\n  });\n  if (activeScenesCount !== 1) {\n    throw new Error(\"There should always be only one scene active, not \" + activeScenesCount + \".\");\n  }\n  if (nextScenes.length !== scenes.length) {\n    return nextScenes;\n  }\n  if (nextScenes.some(function (scene, index) {\n    return !areScenesShallowEqual(scenes[index], scene);\n  })) {\n    return nextScenes;\n  }\n  return scenes;\n}","map":{"version":3,"names":["shallowEqual","SCENE_KEY_PREFIX","compareKey","one","two","delta","length","compareScenes","index","key","areScenesShallowEqual","isStale","isActive","areRoutesShallowEqual","route","ScenesReducer","scenes","nextState","prevState","descriptors","forEach","scene","descriptor","prevScenes","Map","freshScenes","staleScenes","set","nextKeys","Set","nextRoutes","routes","console","warn","slice","has","Error","add","delete","prevRoutes","lastScene","find","nextScenes","mergeScene","nextScene","prevScene","get","push","sort","activeScenesCount","ii","_objectSpread","some"],"sources":["/Users/zuyax/Developer/rn-starter/node_modules/react-navigation-stack/lib/module/views/ScenesReducer.tsx"],"sourcesContent":["import shallowEqual from '../utils/shallowEqual';\nimport { Scene, Route, NavigationState, SceneDescriptor } from '../types';\n\nconst SCENE_KEY_PREFIX = 'scene_';\n\n/**\n * Helper function to compare route keys (e.g. \"9\", \"11\").\n */\nfunction compareKey(one: string, two: string) {\n  const delta = one.length - two.length;\n  if (delta > 0) {\n    return 1;\n  }\n  if (delta < 0) {\n    return -1;\n  }\n  return one > two ? 1 : -1;\n}\n\n/**\n * Helper function to sort scenes based on their index and view key.\n */\nfunction compareScenes(one: Scene, two: Scene) {\n  if (one.index > two.index) {\n    return 1;\n  }\n  if (one.index < two.index) {\n    return -1;\n  }\n\n  return compareKey(one.key, two.key);\n}\n\n/**\n * Whether two routes are the same.\n */\nfunction areScenesShallowEqual(one: Scene, two: Scene) {\n  return (\n    one.key === two.key &&\n    one.index === two.index &&\n    one.isStale === two.isStale &&\n    one.isActive === two.isActive &&\n    areRoutesShallowEqual(one.route, two.route)\n  );\n}\n\n/**\n * Whether two routes are the same.\n */\nfunction areRoutesShallowEqual(one: Route, two: Route) {\n  if (!one || !two) {\n    return one === two;\n  }\n\n  if (one.key !== two.key) {\n    return false;\n  }\n\n  return shallowEqual(one, two);\n}\n\nexport default function ScenesReducer(\n  scenes: Scene[],\n  nextState: NavigationState,\n  prevState: NavigationState | null,\n  descriptors: { [key: string]: SceneDescriptor }\n) {\n  // Always update the descriptors\n  // This is a workaround for https://github.com/react-navigation/react-navigation/issues/4271\n  // It will be resolved in a better way when we re-write Transitioner\n  scenes.forEach(scene => {\n    const { route } = scene;\n    if (descriptors && descriptors[route.key]) {\n      scene.descriptor = descriptors[route.key];\n    }\n  });\n\n  // Bail out early if we didn't update the state\n  if (prevState === nextState) {\n    return scenes;\n  }\n\n  const prevScenes = new Map();\n  const freshScenes = new Map();\n  const staleScenes = new Map();\n\n  // Populate stale scenes from previous scenes marked as stale.\n  scenes.forEach(scene => {\n    const { key } = scene;\n    if (scene.isStale) {\n      staleScenes.set(key, scene);\n    }\n    prevScenes.set(key, scene);\n  });\n\n  const nextKeys = new Set();\n  let nextRoutes = nextState.routes;\n  if (nextRoutes.length > nextState.index + 1) {\n    console.warn(\n      'StackRouter provided invalid state, index should always be the top route'\n    );\n    nextRoutes = nextState.routes.slice(0, nextState.index + 1);\n  }\n\n  nextRoutes.forEach((route, index) => {\n    const key = SCENE_KEY_PREFIX + route.key;\n\n    let descriptor = descriptors && descriptors[route.key];\n\n    const scene: Scene = {\n      index,\n      isActive: false,\n      isStale: false,\n      key,\n      route,\n      descriptor,\n    };\n\n    if (nextKeys.has(key)) {\n      throw new Error(\n        `navigation.state.routes[${index}].key \"${key}\" conflicts with ` +\n          'another route!'\n      );\n    }\n\n    nextKeys.add(key);\n\n    if (staleScenes.has(key)) {\n      // A previously `stale` scene is now part of the nextState, so we\n      // revive it by removing it from the stale scene map.\n      staleScenes.delete(key);\n    }\n    freshScenes.set(key, scene);\n  });\n\n  if (prevState) {\n    let prevRoutes = prevState.routes;\n    if (prevRoutes.length > prevState.index + 1) {\n      console.warn(\n        'StackRouter provided invalid state, index should always be the top route'\n      );\n      prevRoutes = prevRoutes.slice(0, prevState.index + 1);\n    }\n    // Look at the previous routes and classify any removed scenes as `stale`.\n    prevRoutes.forEach((route, index) => {\n      const key = SCENE_KEY_PREFIX + route.key;\n      if (freshScenes.has(key)) {\n        return;\n      }\n      const lastScene = scenes.find(scene => scene.route.key === route.key);\n\n      // We can get into a weird place where we have a queued transition and then clobber\n      // that transition without ever actually rendering the scene, in which case\n      // there is no lastScene. If the descriptor is not available on the lastScene\n      // or the descriptors prop then we just skip adding it to stale scenes and it's\n      // not ever rendered.\n      const descriptor = lastScene\n        ? lastScene.descriptor\n        : descriptors[route.key];\n\n      if (descriptor) {\n        staleScenes.set(key, {\n          index,\n          isActive: false,\n          isStale: true,\n          key,\n          route,\n          descriptor,\n        });\n      }\n    });\n  }\n\n  const nextScenes: Scene[] = [];\n\n  const mergeScene = (nextScene: Scene) => {\n    const { key } = nextScene;\n    const prevScene = prevScenes.has(key) ? prevScenes.get(key) : null;\n    if (prevScene && areScenesShallowEqual(prevScene, nextScene)) {\n      // Reuse `prevScene` as `scene` so view can avoid unnecessary re-render.\n      // This assumes that the scene's navigation state is immutable.\n      nextScenes.push(prevScene);\n    } else {\n      nextScenes.push(nextScene);\n    }\n  };\n\n  staleScenes.forEach(mergeScene);\n  freshScenes.forEach(mergeScene);\n\n  nextScenes.sort(compareScenes);\n\n  let activeScenesCount = 0;\n  nextScenes.forEach((scene, ii) => {\n    const isActive = !scene.isStale && scene.index === nextState.index;\n    if (isActive !== scene.isActive) {\n      nextScenes[ii] = {\n        ...scene,\n        isActive,\n      };\n    }\n    if (isActive) {\n      activeScenesCount++;\n    }\n  });\n\n  if (activeScenesCount !== 1) {\n    throw new Error(\n      `There should always be only one scene active, not ${activeScenesCount}.`\n    );\n  }\n\n  if (nextScenes.length !== scenes.length) {\n    return nextScenes;\n  }\n\n  if (\n    nextScenes.some(\n      (scene, index) => !areScenesShallowEqual(scenes[index], scene)\n    )\n  ) {\n    return nextScenes;\n  }\n\n  // scenes haven't changed.\n  return scenes;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}