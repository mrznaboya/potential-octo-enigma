{"ast":null,"code":"function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nexport default {\n  get name() {\n    return 'ExponentSpeech';\n  },\n  speak(id, text, options) {\n    return _asyncToGenerator(function* () {\n      var {\n        SpeechSynthesisUtterance\n      } = global.window;\n      var message = new SpeechSynthesisUtterance();\n      if ('rate' in options) {\n        message.rate = options.rate;\n      }\n      if ('pitch' in options) {\n        message.pitch = options.pitch;\n      }\n      if ('language' in options) {\n        message.lang = options.language;\n      }\n      if ('volume' in options) {\n        message.volume = options.volume;\n      }\n      if ('_voiceIndex' in options && options._voiceIndex != null) {\n        var voices = window.speechSynthesis.getVoices();\n        message.voice = voices[Math.min(voices.length - 1, Math.max(0, options._voiceIndex))];\n      }\n      if ('onStart' in options) {\n        message.onstart = options.onStart;\n      }\n      if ('onDone' in options) {\n        message.onend = options.onDone;\n      }\n      if ('onError' in options) {\n        message.onerror = options.onError;\n      }\n      if ('onPause' in options) {\n        message.onpause = options.onPause;\n      }\n      if ('onResume' in options) {\n        message.onresume = options.onResume;\n      }\n      if ('onMark' in options) {\n        message.onmark = options.onMark;\n      }\n      if ('onBoundary' in options) {\n        message.onboundary = options.onBoundary;\n      }\n      message.text = text;\n      window.speechSynthesis.speak(message);\n      return message;\n    })();\n  },\n  isSpeaking() {\n    return _asyncToGenerator(function* () {\n      return window.speechSynthesis.speaking;\n    })();\n  },\n  stop() {\n    return _asyncToGenerator(function* () {\n      return window.speechSynthesis.cancel();\n    })();\n  },\n  pause() {\n    return _asyncToGenerator(function* () {\n      return window.speechSynthesis.pause();\n    })();\n  },\n  resume() {\n    return _asyncToGenerator(function* () {\n      return window.speechSynthesis.resume();\n    })();\n  }\n};","map":{"version":3,"names":["name","speak","id","text","options","_asyncToGenerator","SpeechSynthesisUtterance","global","window","message","rate","pitch","lang","language","volume","_voiceIndex","voices","speechSynthesis","getVoices","voice","Math","min","length","max","onstart","onStart","onend","onDone","onerror","onError","onpause","onPause","onresume","onResume","onmark","onMark","onboundary","onBoundary","isSpeaking","speaking","stop","cancel","pause","resume"],"sources":["/Users/zuyax/Developer/rn-starter/node_modules/expo-speech/src/Speech/ExponentSpeech.web.ts"],"sourcesContent":["import { SpeechOptions } from './Speech.types';\n\nexport default {\n  get name(): string {\n    return 'ExponentSpeech';\n  },\n  async speak(id: string, text: string, options: SpeechOptions): Promise<SpeechSynthesisUtterance> {\n    // @ts-ignore\n    const { SpeechSynthesisUtterance } = global.window;\n\n    const message = new SpeechSynthesisUtterance();\n\n    if ('rate' in options) {\n      message.rate = options.rate;\n    }\n    if ('pitch' in options) {\n      message.pitch = options.pitch;\n    }\n    if ('language' in options) {\n      message.lang = options.language;\n    }\n    if ('volume' in options) {\n      message.volume = options.volume;\n    }\n    if ('_voiceIndex' in options && options._voiceIndex != null) {\n      const voices = window.speechSynthesis.getVoices();\n      message.voice = voices[Math.min(voices.length - 1, Math.max(0, options._voiceIndex))];\n    }\n    if ('onStart' in options) {\n      message.onstart = options.onStart;\n    }\n    if ('onDone' in options) {\n      message.onend = options.onDone;\n    }\n    if ('onError' in options) {\n      message.onerror = options.onError;\n    }\n    if ('onPause' in options) {\n      message.onpause = options.onPause;\n    }\n    if ('onResume' in options) {\n      message.onresume = options.onResume;\n    }\n    if ('onMark' in options) {\n      message.onmark = options.onMark;\n    }\n    if ('onBoundary' in options) {\n      message.onboundary = options.onBoundary;\n    }\n    message.text = text;\n    window.speechSynthesis.speak(message);\n\n    return message;\n  },\n  async isSpeaking(): Promise<Boolean> {\n    return window.speechSynthesis.speaking;\n  },\n  async stop(): Promise<void> {\n    return window.speechSynthesis.cancel();\n  },\n  async pause(): Promise<void> {\n    return window.speechSynthesis.pause();\n  },\n  async resume(): Promise<void> {\n    return window.speechSynthesis.resume();\n  },\n};\n"],"mappings":";;AAEA,eAAe;EACb,IAAIA,IAAIA,CAAA;IACN,OAAO,gBAAgB;EACzB,CAAC;EACKC,KAAKA,CAACC,EAAU,EAAEC,IAAY,EAAEC,OAAsB;IAAA,OAAAC,iBAAA;MAE1D,IAAM;QAAEC;MAAwB,CAAE,GAAGC,MAAM,CAACC,MAAM;MAElD,IAAMC,OAAO,GAAG,IAAIH,wBAAwB,EAAE;MAE9C,IAAI,MAAM,IAAIF,OAAO,EAAE;QACrBK,OAAO,CAACC,IAAI,GAAGN,OAAO,CAACM,IAAI;;MAE7B,IAAI,OAAO,IAAIN,OAAO,EAAE;QACtBK,OAAO,CAACE,KAAK,GAAGP,OAAO,CAACO,KAAK;;MAE/B,IAAI,UAAU,IAAIP,OAAO,EAAE;QACzBK,OAAO,CAACG,IAAI,GAAGR,OAAO,CAACS,QAAQ;;MAEjC,IAAI,QAAQ,IAAIT,OAAO,EAAE;QACvBK,OAAO,CAACK,MAAM,GAAGV,OAAO,CAACU,MAAM;;MAEjC,IAAI,aAAa,IAAIV,OAAO,IAAIA,OAAO,CAACW,WAAW,IAAI,IAAI,EAAE;QAC3D,IAAMC,MAAM,GAAGR,MAAM,CAACS,eAAe,CAACC,SAAS,EAAE;QACjDT,OAAO,CAACU,KAAK,GAAGH,MAAM,CAACI,IAAI,CAACC,GAAG,CAACL,MAAM,CAACM,MAAM,GAAG,CAAC,EAAEF,IAAI,CAACG,GAAG,CAAC,CAAC,EAAEnB,OAAO,CAACW,WAAW,CAAC,CAAC,CAAC;;MAEvF,IAAI,SAAS,IAAIX,OAAO,EAAE;QACxBK,OAAO,CAACe,OAAO,GAAGpB,OAAO,CAACqB,OAAO;;MAEnC,IAAI,QAAQ,IAAIrB,OAAO,EAAE;QACvBK,OAAO,CAACiB,KAAK,GAAGtB,OAAO,CAACuB,MAAM;;MAEhC,IAAI,SAAS,IAAIvB,OAAO,EAAE;QACxBK,OAAO,CAACmB,OAAO,GAAGxB,OAAO,CAACyB,OAAO;;MAEnC,IAAI,SAAS,IAAIzB,OAAO,EAAE;QACxBK,OAAO,CAACqB,OAAO,GAAG1B,OAAO,CAAC2B,OAAO;;MAEnC,IAAI,UAAU,IAAI3B,OAAO,EAAE;QACzBK,OAAO,CAACuB,QAAQ,GAAG5B,OAAO,CAAC6B,QAAQ;;MAErC,IAAI,QAAQ,IAAI7B,OAAO,EAAE;QACvBK,OAAO,CAACyB,MAAM,GAAG9B,OAAO,CAAC+B,MAAM;;MAEjC,IAAI,YAAY,IAAI/B,OAAO,EAAE;QAC3BK,OAAO,CAAC2B,UAAU,GAAGhC,OAAO,CAACiC,UAAU;;MAEzC5B,OAAO,CAACN,IAAI,GAAGA,IAAI;MACnBK,MAAM,CAACS,eAAe,CAAChB,KAAK,CAACQ,OAAO,CAAC;MAErC,OAAOA,OAAO;IAAC;EACjB,CAAC;EACK6B,UAAUA,CAAA;IAAA,OAAAjC,iBAAA;MACd,OAAOG,MAAM,CAACS,eAAe,CAACsB,QAAQ;IAAC;EACzC,CAAC;EACKC,IAAIA,CAAA;IAAA,OAAAnC,iBAAA;MACR,OAAOG,MAAM,CAACS,eAAe,CAACwB,MAAM,EAAE;IAAC;EACzC,CAAC;EACKC,KAAKA,CAAA;IAAA,OAAArC,iBAAA;MACT,OAAOG,MAAM,CAACS,eAAe,CAACyB,KAAK,EAAE;IAAC;EACxC,CAAC;EACKC,MAAMA,CAAA;IAAA,OAAAtC,iBAAA;MACV,OAAOG,MAAM,CAACS,eAAe,CAAC0B,MAAM,EAAE;IAAC;EACzC;CACD"},"metadata":{},"sourceType":"module","externalDependencies":[]}