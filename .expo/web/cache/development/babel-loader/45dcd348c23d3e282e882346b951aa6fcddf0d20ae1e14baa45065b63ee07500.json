{"ast":null,"code":"function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nimport { EventEmitter, Platform } from '@unimodules/core';\nimport invariant from 'invariant';\nimport ExpoLocation from \"./ExpoLocation\";\nvar LocationEventEmitter = new EventEmitter(ExpoLocation);\n;\nvar LocationAccuracy;\n(function (LocationAccuracy) {\n  LocationAccuracy[LocationAccuracy[\"Lowest\"] = 1] = \"Lowest\";\n  LocationAccuracy[LocationAccuracy[\"Low\"] = 2] = \"Low\";\n  LocationAccuracy[LocationAccuracy[\"Balanced\"] = 3] = \"Balanced\";\n  LocationAccuracy[LocationAccuracy[\"High\"] = 4] = \"High\";\n  LocationAccuracy[LocationAccuracy[\"Highest\"] = 5] = \"Highest\";\n  LocationAccuracy[LocationAccuracy[\"BestForNavigation\"] = 6] = \"BestForNavigation\";\n})(LocationAccuracy || (LocationAccuracy = {}));\nvar LocationActivityType;\n(function (LocationActivityType) {\n  LocationActivityType[LocationActivityType[\"Other\"] = 1] = \"Other\";\n  LocationActivityType[LocationActivityType[\"AutomotiveNavigation\"] = 2] = \"AutomotiveNavigation\";\n  LocationActivityType[LocationActivityType[\"Fitness\"] = 3] = \"Fitness\";\n  LocationActivityType[LocationActivityType[\"OtherNavigation\"] = 4] = \"OtherNavigation\";\n  LocationActivityType[LocationActivityType[\"Airborne\"] = 5] = \"Airborne\";\n})(LocationActivityType || (LocationActivityType = {}));\nexport { LocationAccuracy as Accuracy, LocationActivityType as ActivityType };\nexport var GeofencingEventType;\n(function (GeofencingEventType) {\n  GeofencingEventType[GeofencingEventType[\"Enter\"] = 1] = \"Enter\";\n  GeofencingEventType[GeofencingEventType[\"Exit\"] = 2] = \"Exit\";\n})(GeofencingEventType || (GeofencingEventType = {}));\nexport var GeofencingRegionState;\n(function (GeofencingRegionState) {\n  GeofencingRegionState[GeofencingRegionState[\"Unknown\"] = 0] = \"Unknown\";\n  GeofencingRegionState[GeofencingRegionState[\"Inside\"] = 1] = \"Inside\";\n  GeofencingRegionState[GeofencingRegionState[\"Outside\"] = 2] = \"Outside\";\n})(GeofencingRegionState || (GeofencingRegionState = {}));\nvar nextWatchId = 0;\nvar headingId;\nfunction _getNextWatchId() {\n  nextWatchId++;\n  return nextWatchId;\n}\nfunction _getCurrentWatchId() {\n  return nextWatchId;\n}\nvar watchCallbacks = {};\nvar deviceEventSubscription;\nvar headingEventSub;\nvar googleApiKey;\nvar googleApiUrl = 'https://maps.googleapis.com/maps/api/geocode/json';\nexport function getProviderStatusAsync() {\n  return _getProviderStatusAsync.apply(this, arguments);\n}\nfunction _getProviderStatusAsync() {\n  _getProviderStatusAsync = _asyncToGenerator(function* () {\n    return ExpoLocation.getProviderStatusAsync();\n  });\n  return _getProviderStatusAsync.apply(this, arguments);\n}\nexport function enableNetworkProviderAsync() {\n  return _enableNetworkProviderAsync.apply(this, arguments);\n}\nfunction _enableNetworkProviderAsync() {\n  _enableNetworkProviderAsync = _asyncToGenerator(function* () {\n    if (Platform.OS === 'android') {\n      return ExpoLocation.enableNetworkProviderAsync();\n    }\n  });\n  return _enableNetworkProviderAsync.apply(this, arguments);\n}\nexport function getCurrentPositionAsync() {\n  return _getCurrentPositionAsync.apply(this, arguments);\n}\nfunction _getCurrentPositionAsync() {\n  _getCurrentPositionAsync = _asyncToGenerator(function* () {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return ExpoLocation.getCurrentPositionAsync(options);\n  });\n  return _getCurrentPositionAsync.apply(this, arguments);\n}\nexport function getHeadingAsync() {\n  return _getHeadingAsync.apply(this, arguments);\n}\nfunction _getHeadingAsync() {\n  _getHeadingAsync = _asyncToGenerator(function* () {\n    return new Promise(function () {\n      var _ref2 = _asyncToGenerator(function* (resolve, reject) {\n        try {\n          if (headingEventSub) {\n            var tries = 0;\n            var headingSub = LocationEventEmitter.addListener('Expo.headingChanged', _ref3 => {\n              var {\n                heading\n              } = _ref3;\n              if (heading.accuracy > 1 || tries > 5) {\n                resolve(heading);\n                LocationEventEmitter.removeSubscription(headingSub);\n              } else {\n                tries += 1;\n              }\n            });\n          } else {\n            var done = false;\n            var subscription;\n            var _tries = 0;\n            subscription = yield watchHeadingAsync(heading => {\n              if (!done) {\n                if (heading.accuracy > 1 || _tries > 5) {\n                  subscription.remove();\n                  resolve(heading);\n                  done = true;\n                } else {\n                  _tries += 1;\n                }\n              } else {\n                subscription.remove();\n              }\n            });\n            if (done) {\n              subscription.remove();\n            }\n          }\n        } catch (e) {\n          reject(e);\n        }\n      });\n      return function (_x17, _x18) {\n        return _ref2.apply(this, arguments);\n      };\n    }());\n  });\n  return _getHeadingAsync.apply(this, arguments);\n}\nexport function watchHeadingAsync(_x) {\n  return _watchHeadingAsync.apply(this, arguments);\n}\nfunction _watchHeadingAsync() {\n  _watchHeadingAsync = _asyncToGenerator(function* (callback) {\n    if (headingEventSub) {\n      _removeHeadingWatcher(headingId);\n    }\n    headingEventSub = LocationEventEmitter.addListener('Expo.headingChanged', _ref4 => {\n      var {\n        watchId,\n        heading\n      } = _ref4;\n      var callback = watchCallbacks[watchId];\n      if (callback) {\n        callback(heading);\n      } else {\n        ExpoLocation.removeWatchAsync(watchId);\n      }\n    });\n    headingId = _getNextWatchId();\n    watchCallbacks[headingId] = callback;\n    yield ExpoLocation.watchDeviceHeading(headingId);\n    return {\n      remove() {\n        _removeHeadingWatcher(headingId);\n      }\n    };\n  });\n  return _watchHeadingAsync.apply(this, arguments);\n}\nfunction _removeHeadingWatcher(watchId) {\n  if (!watchCallbacks[watchId]) {\n    return;\n  }\n  delete watchCallbacks[watchId];\n  ExpoLocation.removeWatchAsync(watchId);\n  if (headingEventSub) {\n    LocationEventEmitter.removeSubscription(headingEventSub);\n    headingEventSub = null;\n  }\n}\nfunction _maybeInitializeEmitterSubscription() {\n  if (!deviceEventSubscription) {\n    deviceEventSubscription = LocationEventEmitter.addListener('Expo.locationChanged', _ref => {\n      var {\n        watchId,\n        location\n      } = _ref;\n      var callback = watchCallbacks[watchId];\n      if (callback) {\n        callback(location);\n      } else {\n        ExpoLocation.removeWatchAsync(watchId);\n      }\n    });\n  }\n}\nexport function geocodeAsync(_x2) {\n  return _geocodeAsync.apply(this, arguments);\n}\nfunction _geocodeAsync() {\n  _geocodeAsync = _asyncToGenerator(function* (address) {\n    return ExpoLocation.geocodeAsync(address).catch(error => {\n      var platformUsesGoogleMaps = Platform.OS === 'android' || Platform.OS === 'web';\n      if (platformUsesGoogleMaps && error.code === 'E_NO_GEOCODER') {\n        if (!googleApiKey) {\n          throw new Error(error.message + ' Please set a Google API Key to use geocoding.');\n        }\n        return _googleGeocodeAsync(address);\n      }\n      throw error;\n    });\n  });\n  return _geocodeAsync.apply(this, arguments);\n}\nexport function reverseGeocodeAsync(_x3) {\n  return _reverseGeocodeAsync.apply(this, arguments);\n}\nfunction _reverseGeocodeAsync() {\n  _reverseGeocodeAsync = _asyncToGenerator(function* (location) {\n    if (typeof location.latitude !== 'number' || typeof location.longitude !== 'number') {\n      throw new TypeError('Location should be an object with number properties `latitude` and `longitude`.');\n    }\n    return ExpoLocation.reverseGeocodeAsync(location).catch(error => {\n      var platformUsesGoogleMaps = Platform.OS === 'android' || Platform.OS === 'web';\n      if (platformUsesGoogleMaps && error.code === 'E_NO_GEOCODER') {\n        if (!googleApiKey) {\n          throw new Error(error.message + ' Please set a Google API Key to use geocoding.');\n        }\n        return _googleReverseGeocodeAsync(location);\n      }\n      throw error;\n    });\n  });\n  return _reverseGeocodeAsync.apply(this, arguments);\n}\nexport function setApiKey(apiKey) {\n  googleApiKey = apiKey;\n}\nfunction _googleGeocodeAsync(_x4) {\n  return _googleGeocodeAsync2.apply(this, arguments);\n}\nfunction _googleGeocodeAsync2() {\n  _googleGeocodeAsync2 = _asyncToGenerator(function* (address) {\n    var result = yield fetch(\"\".concat(googleApiUrl, \"?key=\").concat(googleApiKey, \"&address=\").concat(encodeURI(address)));\n    var resultObject = yield result.json();\n    var {\n      status\n    } = resultObject;\n    if (status === 'ZERO_RESULTS') {\n      return [];\n    } else if (status !== 'OK') {\n      throw new Error(\"An error occurred during geocoding. \".concat(status));\n    }\n    return resultObject.results.map(result => {\n      var location = result.geometry.location;\n      return {\n        latitude: location.lat,\n        longitude: location.lng\n      };\n    });\n  });\n  return _googleGeocodeAsync2.apply(this, arguments);\n}\nfunction _googleReverseGeocodeAsync(_x5) {\n  return _googleReverseGeocodeAsync2.apply(this, arguments);\n}\nfunction _googleReverseGeocodeAsync2() {\n  _googleReverseGeocodeAsync2 = _asyncToGenerator(function* (options) {\n    var result = yield fetch(\"\".concat(googleApiUrl, \"?key=\").concat(googleApiKey, \"&latlng=\").concat(options.latitude, \",\").concat(options.longitude));\n    var resultObject = yield result.json();\n    if (resultObject.status !== 'OK') {\n      throw new Error('An error occurred during geocoding.');\n    }\n    return resultObject.results.map(result => {\n      var address = {};\n      result.address_components.forEach(component => {\n        if (component.types.includes('locality')) {\n          address.city = component.long_name;\n        } else if (component.types.includes('street_address')) {\n          address.street = component.long_name;\n        } else if (component.types.includes('administrative_area_level_1')) {\n          address.region = component.long_name;\n        } else if (component.types.includes('country')) {\n          address.country = component.long_name;\n        } else if (component.types.includes('postal_code')) {\n          address.postalCode = component.long_name;\n        } else if (component.types.includes('point_of_interest')) {\n          address.name = component.long_name;\n        }\n      });\n      return address;\n    });\n  });\n  return _googleReverseGeocodeAsync2.apply(this, arguments);\n}\nfunction watchPosition(success, error, options) {\n  _maybeInitializeEmitterSubscription();\n  var watchId = _getNextWatchId();\n  watchCallbacks[watchId] = success;\n  ExpoLocation.watchPositionImplAsync(watchId, options).catch(err => {\n    _removeWatcher(watchId);\n    error({\n      watchId,\n      message: err.message,\n      code: err.code\n    });\n  });\n  return watchId;\n}\nexport function watchPositionAsync(_x6, _x7) {\n  return _watchPositionAsync.apply(this, arguments);\n}\nfunction _watchPositionAsync() {\n  _watchPositionAsync = _asyncToGenerator(function* (options, callback) {\n    _maybeInitializeEmitterSubscription();\n    var watchId = _getNextWatchId();\n    watchCallbacks[watchId] = callback;\n    yield ExpoLocation.watchPositionImplAsync(watchId, options);\n    return {\n      remove() {\n        _removeWatcher(watchId);\n      }\n    };\n  });\n  return _watchPositionAsync.apply(this, arguments);\n}\nfunction clearWatch(watchId) {\n  _removeWatcher(watchId);\n}\nfunction _removeWatcher(watchId) {\n  if (!watchCallbacks[watchId]) {\n    return;\n  }\n  ExpoLocation.removeWatchAsync(watchId);\n  delete watchCallbacks[watchId];\n  if (Object.keys(watchCallbacks).length === 0 && deviceEventSubscription) {\n    LocationEventEmitter.removeSubscription(deviceEventSubscription);\n    deviceEventSubscription = null;\n  }\n}\nfunction getCurrentPosition(success) {\n  var error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  invariant(typeof success === 'function', 'Must provide a valid success callback.');\n  invariant(typeof options === 'object', 'options must be an object.');\n  _getCurrentPositionAsyncWrapper(success, error, options);\n}\nfunction _getCurrentPositionAsyncWrapper(_x8, _x9, _x10) {\n  return _getCurrentPositionAsyncWrapper2.apply(this, arguments);\n}\nfunction _getCurrentPositionAsyncWrapper2() {\n  _getCurrentPositionAsyncWrapper2 = _asyncToGenerator(function* (success, error, options) {\n    try {\n      yield ExpoLocation.requestPermissionsAsync();\n      var result = yield getCurrentPositionAsync(options);\n      success(result);\n    } catch (e) {\n      error(e);\n    }\n  });\n  return _getCurrentPositionAsyncWrapper2.apply(this, arguments);\n}\nexport function requestPermissionsAsync() {\n  return _requestPermissionsAsync.apply(this, arguments);\n}\nfunction _requestPermissionsAsync() {\n  _requestPermissionsAsync = _asyncToGenerator(function* () {\n    yield ExpoLocation.requestPermissionsAsync();\n  });\n  return _requestPermissionsAsync.apply(this, arguments);\n}\nexport function hasServicesEnabledAsync() {\n  return _hasServicesEnabledAsync.apply(this, arguments);\n}\nfunction _hasServicesEnabledAsync() {\n  _hasServicesEnabledAsync = _asyncToGenerator(function* () {\n    return yield ExpoLocation.hasServicesEnabledAsync();\n  });\n  return _hasServicesEnabledAsync.apply(this, arguments);\n}\nfunction _validateTaskName(taskName) {\n  invariant(taskName && typeof taskName === 'string', '`taskName` must be a non-empty string.');\n}\nexport function isBackgroundLocationAvailableAsync() {\n  return _isBackgroundLocationAvailableAsync.apply(this, arguments);\n}\nfunction _isBackgroundLocationAvailableAsync() {\n  _isBackgroundLocationAvailableAsync = _asyncToGenerator(function* () {\n    var providerStatus = yield getProviderStatusAsync();\n    return providerStatus.backgroundModeEnabled;\n  });\n  return _isBackgroundLocationAvailableAsync.apply(this, arguments);\n}\nexport function startLocationUpdatesAsync(_x11) {\n  return _startLocationUpdatesAsync.apply(this, arguments);\n}\nfunction _startLocationUpdatesAsync() {\n  _startLocationUpdatesAsync = _asyncToGenerator(function* (taskName) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      accuracy: LocationAccuracy.Balanced\n    };\n    _validateTaskName(taskName);\n    yield ExpoLocation.startLocationUpdatesAsync(taskName, options);\n  });\n  return _startLocationUpdatesAsync.apply(this, arguments);\n}\nexport function stopLocationUpdatesAsync(_x12) {\n  return _stopLocationUpdatesAsync.apply(this, arguments);\n}\nfunction _stopLocationUpdatesAsync() {\n  _stopLocationUpdatesAsync = _asyncToGenerator(function* (taskName) {\n    _validateTaskName(taskName);\n    yield ExpoLocation.stopLocationUpdatesAsync(taskName);\n  });\n  return _stopLocationUpdatesAsync.apply(this, arguments);\n}\nexport function hasStartedLocationUpdatesAsync(_x13) {\n  return _hasStartedLocationUpdatesAsync.apply(this, arguments);\n}\nfunction _hasStartedLocationUpdatesAsync() {\n  _hasStartedLocationUpdatesAsync = _asyncToGenerator(function* (taskName) {\n    _validateTaskName(taskName);\n    return ExpoLocation.hasStartedLocationUpdatesAsync(taskName);\n  });\n  return _hasStartedLocationUpdatesAsync.apply(this, arguments);\n}\nfunction _validateRegions(regions) {\n  if (!regions || regions.length === 0) {\n    throw new Error('Regions array cannot be empty. Use `stopGeofencingAsync` if you want to stop geofencing all regions');\n  }\n  for (var region of regions) {\n    if (typeof region.latitude !== 'number') {\n      throw new TypeError(\"Region's latitude must be a number. Got '\".concat(region.latitude, \"' instead.\"));\n    }\n    if (typeof region.longitude !== 'number') {\n      throw new TypeError(\"Region's longitude must be a number. Got '\".concat(region.longitude, \"' instead.\"));\n    }\n    if (typeof region.radius !== 'number') {\n      throw new TypeError(\"Region's radius must be a number. Got '\".concat(region.radius, \"' instead.\"));\n    }\n  }\n}\nexport function startGeofencingAsync(_x14) {\n  return _startGeofencingAsync.apply(this, arguments);\n}\nfunction _startGeofencingAsync() {\n  _startGeofencingAsync = _asyncToGenerator(function* (taskName) {\n    var regions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    _validateTaskName(taskName);\n    _validateRegions(regions);\n    yield ExpoLocation.startGeofencingAsync(taskName, {\n      regions\n    });\n  });\n  return _startGeofencingAsync.apply(this, arguments);\n}\nexport function stopGeofencingAsync(_x15) {\n  return _stopGeofencingAsync.apply(this, arguments);\n}\nfunction _stopGeofencingAsync() {\n  _stopGeofencingAsync = _asyncToGenerator(function* (taskName) {\n    _validateTaskName(taskName);\n    yield ExpoLocation.stopGeofencingAsync(taskName);\n  });\n  return _stopGeofencingAsync.apply(this, arguments);\n}\nexport function hasStartedGeofencingAsync(_x16) {\n  return _hasStartedGeofencingAsync.apply(this, arguments);\n}\nfunction _hasStartedGeofencingAsync() {\n  _hasStartedGeofencingAsync = _asyncToGenerator(function* (taskName) {\n    _validateTaskName(taskName);\n    return ExpoLocation.hasStartedGeofencingAsync(taskName);\n  });\n  return _hasStartedGeofencingAsync.apply(this, arguments);\n}\nexport function installWebGeolocationPolyfill() {\n  if (Platform.OS !== 'web') {\n    window.navigator.geolocation = {\n      getCurrentPosition,\n      watchPosition,\n      clearWatch,\n      stopObserving: () => {}\n    };\n  }\n}\nexport { LocationEventEmitter as EventEmitter, _getCurrentWatchId };","map":{"version":3,"names":["EventEmitter","Platform","invariant","ExpoLocation","LocationEventEmitter","LocationAccuracy","LocationActivityType","Accuracy","ActivityType","GeofencingEventType","GeofencingRegionState","nextWatchId","headingId","_getNextWatchId","_getCurrentWatchId","watchCallbacks","deviceEventSubscription","headingEventSub","googleApiKey","googleApiUrl","getProviderStatusAsync","_getProviderStatusAsync","apply","arguments","_asyncToGenerator","enableNetworkProviderAsync","_enableNetworkProviderAsync","OS","getCurrentPositionAsync","_getCurrentPositionAsync","options","length","undefined","getHeadingAsync","_getHeadingAsync","Promise","_ref2","resolve","reject","tries","headingSub","addListener","_ref3","heading","accuracy","removeSubscription","done","subscription","watchHeadingAsync","remove","e","_x17","_x18","_x","_watchHeadingAsync","callback","_removeHeadingWatcher","_ref4","watchId","removeWatchAsync","watchDeviceHeading","_maybeInitializeEmitterSubscription","_ref","location","geocodeAsync","_x2","_geocodeAsync","address","catch","error","platformUsesGoogleMaps","code","Error","message","_googleGeocodeAsync","reverseGeocodeAsync","_x3","_reverseGeocodeAsync","latitude","longitude","TypeError","_googleReverseGeocodeAsync","setApiKey","apiKey","_x4","_googleGeocodeAsync2","result","fetch","concat","encodeURI","resultObject","json","status","results","map","geometry","lat","lng","_x5","_googleReverseGeocodeAsync2","address_components","forEach","component","types","includes","city","long_name","street","region","country","postalCode","name","watchPosition","success","watchPositionImplAsync","err","_removeWatcher","watchPositionAsync","_x6","_x7","_watchPositionAsync","clearWatch","Object","keys","getCurrentPosition","_getCurrentPositionAsyncWrapper","_x8","_x9","_x10","_getCurrentPositionAsyncWrapper2","requestPermissionsAsync","_requestPermissionsAsync","hasServicesEnabledAsync","_hasServicesEnabledAsync","_validateTaskName","taskName","isBackgroundLocationAvailableAsync","_isBackgroundLocationAvailableAsync","providerStatus","backgroundModeEnabled","startLocationUpdatesAsync","_x11","_startLocationUpdatesAsync","Balanced","stopLocationUpdatesAsync","_x12","_stopLocationUpdatesAsync","hasStartedLocationUpdatesAsync","_x13","_hasStartedLocationUpdatesAsync","_validateRegions","regions","radius","startGeofencingAsync","_x14","_startGeofencingAsync","stopGeofencingAsync","_x15","_stopGeofencingAsync","hasStartedGeofencingAsync","_x16","_hasStartedGeofencingAsync","installWebGeolocationPolyfill","window","navigator","geolocation","stopObserving"],"sources":["/Users/zuyax/Developer/rn-starter/node_modules/expo-location/src/Location.ts"],"sourcesContent":["import { EventEmitter, Platform } from '@unimodules/core';\nimport invariant from 'invariant';\n\nimport ExpoLocation from './ExpoLocation';\n\nconst LocationEventEmitter = new EventEmitter(ExpoLocation);\n\nexport interface ProviderStatus {\n  locationServicesEnabled: boolean;\n  backgroundModeEnabled: boolean;\n  gpsAvailable?: boolean;\n  networkAvailable?: boolean;\n  passiveAvailable?: boolean;\n}\n\nexport interface LocationOptions {\n  accuracy?: LocationAccuracy;\n  enableHighAccuracy?: boolean;\n  timeInterval?: number;\n  distanceInterval?: number;\n  timeout?: number;\n  mayShowUserSettingsDialog?: boolean;\n}\n\nexport interface LocationData {\n  coords: {\n    latitude: number;\n    longitude: number;\n    altitude: number;\n    accuracy: number;\n    heading: number;\n    speed: number;\n  };\n  timestamp: number;\n}\n\nexport interface HeadingData {\n  trueHeading: number;\n  magHeading: number;\n  accuracy: number;\n}\n\nexport interface GeocodedLocation {\n  latitude: number;\n  longitude: number;\n  altitude?: number;\n  accuracy?: number;\n}\n\nexport interface Address {\n  city: string;\n  street: string;\n  region: string;\n  country: string;\n  postalCode: string;\n  name: string;\n}\n\ninterface LocationTaskOptions {\n  accuracy?: LocationAccuracy;\n  timeInterval?: number; // Android only\n  distanceInterval?: number;\n  showsBackgroundLocationIndicator?: boolean; // iOS only\n  deferredUpdatesDistance?: number;\n  deferredUpdatesTimeout?: number;\n  deferredUpdatesInterval?: number;\n\n  // iOS only\n  activityType?: LocationActivityType;\n  pausesUpdatesAutomatically?: boolean;\n\n  foregroundService?: {\n    notificationTitle: string;\n    notificationBody: string;\n    notificationColor?: string;\n  };\n};\n\ninterface Region {\n  identifier?: string;\n  latitude: number;\n  longitude: number;\n  radius: number;\n  notifyOnEnter?: boolean;\n  notifyOnExit?: boolean;\n}\n\ntype Subscription = {\n  remove: () => void;\n};\ntype LocationCallback = (data: LocationData) => any;\ntype HeadingCallback = (data: HeadingData) => any;\n\nenum LocationAccuracy {\n  Lowest = 1,\n  Low = 2,\n  Balanced = 3,\n  High = 4,\n  Highest = 5,\n  BestForNavigation = 6,\n}\n\nenum LocationActivityType {\n  Other = 1,\n  AutomotiveNavigation = 2,\n  Fitness = 3,\n  OtherNavigation = 4,\n  Airborne = 5,\n}\n\nexport {\n  LocationAccuracy as Accuracy,\n  LocationActivityType as ActivityType,\n};\n\nexport enum GeofencingEventType {\n  Enter = 1,\n  Exit = 2,\n}\n\nexport enum GeofencingRegionState {\n  Unknown = 0,\n  Inside = 1,\n  Outside = 2,\n}\n\nlet nextWatchId = 0;\nlet headingId;\nfunction _getNextWatchId() {\n  nextWatchId++;\n  return nextWatchId;\n}\nfunction _getCurrentWatchId() {\n  return nextWatchId;\n}\n\nlet watchCallbacks: {\n  [watchId: number]: LocationCallback | HeadingCallback;\n} = {};\n\nlet deviceEventSubscription: Subscription | null;\nlet headingEventSub: Subscription | null;\nlet googleApiKey;\nconst googleApiUrl = 'https://maps.googleapis.com/maps/api/geocode/json';\n\nexport async function getProviderStatusAsync(): Promise<ProviderStatus> {\n  return ExpoLocation.getProviderStatusAsync();\n}\n\nexport async function enableNetworkProviderAsync(): Promise<void> {\n  // If network provider is disabled (user's location mode is set to \"Device only\"),\n  // Android's location provider may not give you any results. Use this method in order to ask the user\n  // to change the location mode to \"High accuracy\" which uses Google Play services and enables network provider.\n  // `getCurrentPositionAsync` and `watchPositionAsync` are doing it automatically anyway.\n\n  if (Platform.OS === 'android') {\n    return ExpoLocation.enableNetworkProviderAsync();\n  }\n}\n\nexport async function getCurrentPositionAsync(\n  options: LocationOptions = {}\n): Promise<LocationData> {\n  return ExpoLocation.getCurrentPositionAsync(options);\n}\n\n// Start Compass Module\n\n// To simplify, we will call watchHeadingAsync and wait for one update To ensure accuracy, we wait\n// for a couple of watch updates if the data has low accuracy\nexport async function getHeadingAsync(): Promise<HeadingData> {\n  return new Promise<HeadingData>(async (resolve, reject) => {\n    try {\n      // If there is already a compass active (would be a watch)\n      if (headingEventSub) {\n        let tries = 0;\n        const headingSub = LocationEventEmitter.addListener(\n          'Expo.headingChanged',\n          ({ heading }: { heading: HeadingData }) => {\n            if (heading.accuracy > 1 || tries > 5) {\n              resolve(heading);\n              LocationEventEmitter.removeSubscription(headingSub);\n            } else {\n              tries += 1;\n            }\n          }\n        );\n      } else {\n        let done = false;\n        let subscription;\n        let tries = 0;\n        subscription = await watchHeadingAsync((heading: HeadingData) => {\n          if (!done) {\n            if (heading.accuracy > 1 || tries > 5) {\n              subscription.remove();\n              resolve(heading);\n              done = true;\n            } else {\n              tries += 1;\n            }\n          } else {\n            subscription.remove();\n          }\n        });\n\n        if (done) {\n          subscription.remove();\n        }\n      }\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n\nexport async function watchHeadingAsync(\n  callback: HeadingCallback\n): Promise<{ remove: () => void }> {\n  // Check if there is already a compass event watch.\n  if (headingEventSub) {\n    _removeHeadingWatcher(headingId);\n  }\n\n  headingEventSub = LocationEventEmitter.addListener(\n    'Expo.headingChanged',\n    ({ watchId, heading }: { watchId: string; heading: HeadingData }) => {\n      const callback = watchCallbacks[watchId];\n      if (callback) {\n        callback(heading);\n      } else {\n        ExpoLocation.removeWatchAsync(watchId);\n      }\n    }\n  );\n\n  headingId = _getNextWatchId();\n  watchCallbacks[headingId] = callback;\n  await ExpoLocation.watchDeviceHeading(headingId);\n  return {\n    remove() {\n      _removeHeadingWatcher(headingId);\n    },\n  };\n}\n\n// Removes the compass listener and sub from JS and Native\nfunction _removeHeadingWatcher(watchId) {\n  if (!watchCallbacks[watchId]) {\n    return;\n  }\n  delete watchCallbacks[watchId];\n  ExpoLocation.removeWatchAsync(watchId);\n  if (headingEventSub) {\n    LocationEventEmitter.removeSubscription(headingEventSub);\n    headingEventSub = null;\n  }\n}\n// End Compass Module\n\nfunction _maybeInitializeEmitterSubscription() {\n  if (!deviceEventSubscription) {\n    deviceEventSubscription = LocationEventEmitter.addListener(\n      'Expo.locationChanged',\n      ({ watchId, location }: { watchId: string; location: LocationData }) => {\n        const callback = watchCallbacks[watchId];\n        if (callback) {\n          callback(location);\n        } else {\n          ExpoLocation.removeWatchAsync(watchId);\n        }\n      }\n    );\n  }\n}\n\nexport async function geocodeAsync(address: string): Promise<Array<GeocodedLocation>> {\n  return ExpoLocation.geocodeAsync(address).catch(error => {\n    const platformUsesGoogleMaps = Platform.OS === 'android' || Platform.OS === 'web';\n\n    if (platformUsesGoogleMaps && error.code === 'E_NO_GEOCODER') {\n      if (!googleApiKey) {\n        throw new Error(error.message + ' Please set a Google API Key to use geocoding.');\n      }\n      return _googleGeocodeAsync(address);\n    }\n    throw error;\n  });\n}\n\nexport async function reverseGeocodeAsync(location: {\n  latitude: number;\n  longitude: number;\n}): Promise<Address[]> {\n  if (typeof location.latitude !== 'number' || typeof location.longitude !== 'number') {\n    throw new TypeError(\n      'Location should be an object with number properties `latitude` and `longitude`.'\n    );\n  }\n  return ExpoLocation.reverseGeocodeAsync(location).catch(error => {\n    const platformUsesGoogleMaps = Platform.OS === 'android' || Platform.OS === 'web';\n\n    if (platformUsesGoogleMaps && error.code === 'E_NO_GEOCODER') {\n      if (!googleApiKey) {\n        throw new Error(error.message + ' Please set a Google API Key to use geocoding.');\n      }\n      return _googleReverseGeocodeAsync(location);\n    }\n    throw error;\n  });\n}\n\nexport function setApiKey(apiKey: string) {\n  googleApiKey = apiKey;\n}\n\nasync function _googleGeocodeAsync(address: string): Promise<GeocodedLocation[]> {\n  const result = await fetch(`${googleApiUrl}?key=${googleApiKey}&address=${encodeURI(address)}`);\n  const resultObject = await result.json();\n\n  const { status } = resultObject;\n  if (status === 'ZERO_RESULTS') {\n    return [];\n  } else if (status !== 'OK') {\n    throw new Error(`An error occurred during geocoding. ${status}`);\n  }\n\n  return resultObject.results.map(result => {\n    let location = result.geometry.location;\n    // TODO: This is missing a lot of props\n    return {\n      latitude: location.lat,\n      longitude: location.lng,\n    };\n  });\n}\n\nasync function _googleReverseGeocodeAsync(options: {\n  latitude: number;\n  longitude: number;\n}): Promise<Address[]> {\n  const result = await fetch(\n    `${googleApiUrl}?key=${googleApiKey}&latlng=${options.latitude},${options.longitude}`\n  );\n  const resultObject = await result.json();\n\n  if (resultObject.status !== 'OK') {\n    throw new Error('An error occurred during geocoding.');\n  }\n\n  return resultObject.results.map(result => {\n    const address: any = {};\n\n    result.address_components.forEach(component => {\n      if (component.types.includes('locality')) {\n        address.city = component.long_name;\n      } else if (component.types.includes('street_address')) {\n        address.street = component.long_name;\n      } else if (component.types.includes('administrative_area_level_1')) {\n        address.region = component.long_name;\n      } else if (component.types.includes('country')) {\n        address.country = component.long_name;\n      } else if (component.types.includes('postal_code')) {\n        address.postalCode = component.long_name;\n      } else if (component.types.includes('point_of_interest')) {\n        address.name = component.long_name;\n      }\n    });\n    return address as Address;\n  });\n}\n\n// Polyfill: navigator.geolocation.watchPosition\nfunction watchPosition(\n  success: GeoSuccessCallback,\n  error: GeoErrorCallback,\n  options: LocationOptions\n) {\n  _maybeInitializeEmitterSubscription();\n\n  const watchId = _getNextWatchId();\n  watchCallbacks[watchId] = success;\n\n  ExpoLocation.watchPositionImplAsync(watchId, options).catch(err => {\n    _removeWatcher(watchId);\n    error({ watchId, message: err.message, code: err.code });\n  });\n\n  return watchId;\n}\n\nexport async function watchPositionAsync(options: LocationOptions, callback: LocationCallback) {\n  _maybeInitializeEmitterSubscription();\n\n  const watchId = _getNextWatchId();\n  watchCallbacks[watchId] = callback;\n  await ExpoLocation.watchPositionImplAsync(watchId, options);\n\n  return {\n    remove() {\n      _removeWatcher(watchId);\n    },\n  };\n}\n\n// Polyfill: navigator.geolocation.clearWatch\nfunction clearWatch(watchId: number) {\n  _removeWatcher(watchId);\n}\n\nfunction _removeWatcher(watchId) {\n  // Do nothing if we have already removed the subscription\n  if (!watchCallbacks[watchId]) {\n    return;\n  }\n\n  ExpoLocation.removeWatchAsync(watchId);\n  delete watchCallbacks[watchId];\n  if (Object.keys(watchCallbacks).length === 0 && deviceEventSubscription) {\n    LocationEventEmitter.removeSubscription(deviceEventSubscription);\n    deviceEventSubscription = null;\n  }\n}\n\ntype GeoSuccessCallback = (data: LocationData) => void;\ntype GeoErrorCallback = (error: any) => void;\n\nfunction getCurrentPosition(\n  success: GeoSuccessCallback,\n  error: GeoErrorCallback = () => {},\n  options: LocationOptions = {}\n): void {\n  invariant(typeof success === 'function', 'Must provide a valid success callback.');\n\n  invariant(typeof options === 'object', 'options must be an object.');\n\n  _getCurrentPositionAsyncWrapper(success, error, options);\n}\n\n// This function exists to let us continue to return undefined from getCurrentPosition, while still\n// using async/await for the internal implementation of it\nasync function _getCurrentPositionAsyncWrapper(\n  success: GeoSuccessCallback,\n  error: GeoErrorCallback,\n  options: LocationOptions\n): Promise<any> {\n  try {\n    await ExpoLocation.requestPermissionsAsync();\n    const result = await getCurrentPositionAsync(options);\n    success(result);\n  } catch (e) {\n    error(e);\n  }\n}\n\nexport async function requestPermissionsAsync(): Promise<void> {\n  await ExpoLocation.requestPermissionsAsync();\n}\n\n// --- Location service\n\nexport async function hasServicesEnabledAsync(): Promise<boolean> {\n  return await ExpoLocation.hasServicesEnabledAsync();\n}\n\n// --- Background location updates\n\nfunction _validateTaskName(taskName: string) {\n  invariant(taskName && typeof taskName === 'string', '`taskName` must be a non-empty string.');\n}\n\nexport async function isBackgroundLocationAvailableAsync(): Promise<boolean> {\n  const providerStatus = await getProviderStatusAsync();\n  return providerStatus.backgroundModeEnabled;\n}\n\nexport async function startLocationUpdatesAsync(\n  taskName: string,\n  options: LocationTaskOptions = { accuracy: LocationAccuracy.Balanced }\n): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.startLocationUpdatesAsync(taskName, options);\n}\n\nexport async function stopLocationUpdatesAsync(taskName: string): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.stopLocationUpdatesAsync(taskName);\n}\n\nexport async function hasStartedLocationUpdatesAsync(taskName: string): Promise<boolean> {\n  _validateTaskName(taskName);\n  return ExpoLocation.hasStartedLocationUpdatesAsync(taskName);\n}\n\n// --- Geofencing\n\nfunction _validateRegions(regions: Array<Region>) {\n  if (!regions || regions.length === 0) {\n    throw new Error(\n      'Regions array cannot be empty. Use `stopGeofencingAsync` if you want to stop geofencing all regions'\n    );\n  }\n  for (const region of regions) {\n    if (typeof region.latitude !== 'number') {\n      throw new TypeError(`Region's latitude must be a number. Got '${region.latitude}' instead.`);\n    }\n    if (typeof region.longitude !== 'number') {\n      throw new TypeError(\n        `Region's longitude must be a number. Got '${region.longitude}' instead.`\n      );\n    }\n    if (typeof region.radius !== 'number') {\n      throw new TypeError(`Region's radius must be a number. Got '${region.radius}' instead.`);\n    }\n  }\n}\n\nexport async function startGeofencingAsync(\n  taskName: string,\n  regions: Array<Region> = []\n): Promise<void> {\n  _validateTaskName(taskName);\n  _validateRegions(regions);\n  await ExpoLocation.startGeofencingAsync(taskName, { regions });\n}\n\nexport async function stopGeofencingAsync(taskName: string): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.stopGeofencingAsync(taskName);\n}\n\nexport async function hasStartedGeofencingAsync(taskName: string): Promise<boolean> {\n  _validateTaskName(taskName);\n  return ExpoLocation.hasStartedGeofencingAsync(taskName);\n}\n\nexport function installWebGeolocationPolyfill(): void {\n  if (Platform.OS !== 'web') {\n    // Polyfill navigator.geolocation for interop with the core react-native and web API approach to\n    // geolocation\n    // @ts-ignore\n    window.navigator.geolocation = {\n      getCurrentPosition,\n      watchPosition,\n      clearWatch,\n\n      // We don't polyfill stopObserving, this is an internal method that probably should not even exist\n      // in react-native docs\n      stopObserving: () => {},\n    };\n  }\n}\n\nexport {\n  // For internal purposes\n  LocationEventEmitter as EventEmitter,\n  _getCurrentWatchId,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}