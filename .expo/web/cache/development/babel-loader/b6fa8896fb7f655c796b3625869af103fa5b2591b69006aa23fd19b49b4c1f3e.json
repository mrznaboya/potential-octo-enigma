{"ast":null,"code":"function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nimport { isDataUrl, getMimeTypeFromSource, getEscapedString, resolveUrl, getSourceAndEncodeAsync, formatDataAsUrl } from \"./Utils.web\";\nvar URL_REGEX = /url\\(['\"]?([^'\"]+?)['\"]?\\)/g;\nexport function shouldProcess(string) {\n  if (!string.search) {\n    return false;\n  }\n  return string.search(URL_REGEX) !== -1;\n}\nexport function batchProcessAllSourcesAsync(_x, _x2, _x3) {\n  return _batchProcessAllSourcesAsync.apply(this, arguments);\n}\nfunction _batchProcessAllSourcesAsync() {\n  _batchProcessAllSourcesAsync = _asyncToGenerator(function* (string, baseUrl, get) {\n    if (!shouldProcess(string)) {\n      return string;\n    }\n    var urls = readURLs(string);\n    var done = Promise.resolve(string);\n    var _loop = function _loop(url) {\n      done = done.then(string => processURLAsync(string, url, baseUrl, get));\n    };\n    for (var url of urls) {\n      _loop(url);\n    }\n    return done;\n  });\n  return _batchProcessAllSourcesAsync.apply(this, arguments);\n}\nfunction readURLs(urls) {\n  var result = [];\n  var match;\n  while ((match = URL_REGEX.exec(urls)) !== null) {\n    result.push(match[1]);\n  }\n  return result.filter(url => !isDataUrl(url));\n}\nfunction processURLAsync(_x4, _x5) {\n  return _processURLAsync.apply(this, arguments);\n}\nfunction _processURLAsync() {\n  _processURLAsync = _asyncToGenerator(function* (string, url) {\n    var baseUrl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    var getSourceAsync = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : getSourceAndEncodeAsync;\n    var finalURL = baseUrl ? resolveUrl(url, baseUrl) : url;\n    var data = yield getSourceAsync(finalURL);\n    var dataUrl = formatDataAsUrl(data, getMimeTypeFromSource(url));\n    return string.replace(URLAsRegex(url), \"$1\".concat(dataUrl, \"$3\"));\n  });\n  return _processURLAsync.apply(this, arguments);\n}\nfunction URLAsRegex(url) {\n  return new RegExp(\"(url\\\\(['\\\"]?)(\".concat(getEscapedString(url), \")(['\\\"]?\\\\))\"), 'g');\n}","map":{"version":3,"names":["isDataUrl","getMimeTypeFromSource","getEscapedString","resolveUrl","getSourceAndEncodeAsync","formatDataAsUrl","URL_REGEX","shouldProcess","string","search","batchProcessAllSourcesAsync","_x","_x2","_x3","_batchProcessAllSourcesAsync","apply","arguments","_asyncToGenerator","baseUrl","get","urls","readURLs","done","Promise","resolve","_loop","url","then","processURLAsync","result","match","exec","push","filter","_x4","_x5","_processURLAsync","length","undefined","getSourceAsync","finalURL","data","dataUrl","replace","URLAsRegex","concat","RegExp"],"sources":["/Users/zuyax/Developer/rn-starter/node_modules/expo/src/takeSnapshotAsync/ProcessSources.web.ts"],"sourcesContent":["import {\n  isDataUrl,\n  getMimeTypeFromSource,\n  getEscapedString,\n  resolveUrl,\n  getSourceAndEncodeAsync,\n  formatDataAsUrl,\n} from './Utils.web';\n\nconst URL_REGEX = /url\\(['\"]?([^'\"]+?)['\"]?\\)/g;\n\nexport function shouldProcess(string: string): boolean {\n  if (!string.search) {\n    return false;\n  }\n  return string.search(URL_REGEX) !== -1;\n}\n\nexport async function batchProcessAllSourcesAsync(\n  string: string,\n  baseUrl?: string,\n  get?\n): Promise<string> {\n  if (!shouldProcess(string)) {\n    return string;\n  }\n\n  const urls = readURLs(string);\n\n  let done = Promise.resolve(string);\n  for (const url of urls) {\n    done = done.then(string => processURLAsync(string, url, baseUrl, get));\n  }\n  return done;\n}\n\nfunction readURLs(urls: string): Array<any> {\n  const result: Array<any> = [];\n  let match;\n  while ((match = URL_REGEX.exec(urls)) !== null) {\n    result.push(match[1]);\n  }\n  return result.filter(url => !isDataUrl(url));\n}\n\ntype SourceHandler = (value: string) => Promise<string>;\n\nasync function processURLAsync(\n  string: string,\n  url: string,\n  baseUrl: string | undefined = undefined,\n  getSourceAsync: SourceHandler = getSourceAndEncodeAsync\n): Promise<string> {\n  const finalURL = baseUrl ? resolveUrl(url, baseUrl) : url;\n  const data = await getSourceAsync(finalURL);\n  const dataUrl = formatDataAsUrl(data, getMimeTypeFromSource(url));\n\n  return string.replace(URLAsRegex(url), `$1${dataUrl}$3`);\n}\n\nfunction URLAsRegex(url) {\n  return new RegExp(`(url\\\\(['\"]?)(${getEscapedString(url)})(['\"]?\\\\))`, 'g');\n}\n"],"mappings":";;AAAA,SACEA,SAAS,EACTC,qBAAqB,EACrBC,gBAAgB,EAChBC,UAAU,EACVC,uBAAuB,EACvBC,eAAe;AAGjB,IAAMC,SAAS,GAAG,6BAA6B;AAE/C,OAAM,SAAUC,aAAaA,CAACC,MAAc;EAC1C,IAAI,CAACA,MAAM,CAACC,MAAM,EAAE;IAClB,OAAO,KAAK;;EAEd,OAAOD,MAAM,CAACC,MAAM,CAACH,SAAS,CAAC,KAAK,CAAC,CAAC;AACxC;AAEA,gBAAsBI,2BAA2BA,CAAAC,EAAA,EAAAC,GAAA,EAAAC,GAAA;EAAA,OAAAC,4BAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAgBhD,SAAAF,6BAAA;EAAAA,4BAAA,GAAAG,iBAAA,CAhBM,WACLT,MAAc,EACdU,OAAgB,EAChBC,GAAI;IAEJ,IAAI,CAACZ,aAAa,CAACC,MAAM,CAAC,EAAE;MAC1B,OAAOA,MAAM;;IAGf,IAAMY,IAAI,GAAGC,QAAQ,CAACb,MAAM,CAAC;IAE7B,IAAIc,IAAI,GAAGC,OAAO,CAACC,OAAO,CAAChB,MAAM,CAAC;IAAC,IAAAiB,KAAA,YAAAA,MACxBC,GAAG;MACZJ,IAAI,GAAGA,IAAI,CAACK,IAAI,CAACnB,MAAM,IAAIoB,eAAe,CAACpB,MAAM,EAAEkB,GAAG,EAAER,OAAO,EAAEC,GAAG,CAAC,CAAC;IAAC;IADzE,KAAK,IAAMO,GAAG,IAAIN,IAAI,EAAE;MAAAK,KAAA,CAAbC,GAAG;;IAGd,OAAOJ,IAAI;EACb,CAAC;EAAA,OAAAR,4BAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAED,SAASK,QAAQA,CAACD,IAAY;EAC5B,IAAMS,MAAM,GAAe,EAAE;EAC7B,IAAIC,KAAK;EACT,OAAO,CAACA,KAAK,GAAGxB,SAAS,CAACyB,IAAI,CAACX,IAAI,CAAC,MAAM,IAAI,EAAE;IAC9CS,MAAM,CAACG,IAAI,CAACF,KAAK,CAAC,CAAC,CAAC,CAAC;;EAEvB,OAAOD,MAAM,CAACI,MAAM,CAACP,GAAG,IAAI,CAAC1B,SAAS,CAAC0B,GAAG,CAAC,CAAC;AAC9C;AAAC,SAIcE,eAAeA,CAAAM,GAAA,EAAAC,GAAA;EAAA,OAAAC,gBAAA,CAAArB,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAoB,iBAAA;EAAAA,gBAAA,GAAAnB,iBAAA,CAA9B,WACET,MAAc,EACdkB,GAAW,EAE4C;IAAA,IADvDR,OAAA,GAAAF,SAAA,CAAAqB,MAAA,QAAArB,SAAA,QAAAsB,SAAA,GAAAtB,SAAA,MAA8BsB,SAAS;IAAA,IACvCC,cAAA,GAAAvB,SAAA,CAAAqB,MAAA,QAAArB,SAAA,QAAAsB,SAAA,GAAAtB,SAAA,MAAgCZ,uBAAuB;IAEvD,IAAMoC,QAAQ,GAAGtB,OAAO,GAAGf,UAAU,CAACuB,GAAG,EAAER,OAAO,CAAC,GAAGQ,GAAG;IACzD,IAAMe,IAAI,SAASF,cAAc,CAACC,QAAQ,CAAC;IAC3C,IAAME,OAAO,GAAGrC,eAAe,CAACoC,IAAI,EAAExC,qBAAqB,CAACyB,GAAG,CAAC,CAAC;IAEjE,OAAOlB,MAAM,CAACmC,OAAO,CAACC,UAAU,CAAClB,GAAG,CAAC,OAAAmB,MAAA,CAAOH,OAAO,OAAI,CAAC;EAC1D,CAAC;EAAA,OAAAN,gBAAA,CAAArB,KAAA,OAAAC,SAAA;AAAA;AAED,SAAS4B,UAAUA,CAAClB,GAAG;EACrB,OAAO,IAAIoB,MAAM,mBAAAD,MAAA,CAAkB3C,gBAAgB,CAACwB,GAAG,CAAC,mBAAe,GAAG,CAAC;AAC7E"},"metadata":{},"sourceType":"module","externalDependencies":[]}