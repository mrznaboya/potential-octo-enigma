{"ast":null,"code":"function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nimport { EventEmitter, Platform } from '@unimodules/core';\nexport default class DeviceSensor {\n  constructor(nativeSensorModule, nativeEventName) {\n    this._nativeModule = nativeSensorModule;\n    this._nativeEmitter = new EventEmitter(nativeSensorModule);\n    this._nativeEventName = nativeEventName;\n    this._listenerCount = 0;\n  }\n  addListener(listener) {\n    var subscription = this._nativeEmitter.addListener(this._nativeEventName, listener);\n    subscription.remove = () => this.removeSubscription(subscription);\n    this._listenerCount++;\n    return subscription;\n  }\n  hasListeners() {\n    return this._listenerCount > 0;\n  }\n  getListenerCount() {\n    return this._listenerCount;\n  }\n  removeAllListeners() {\n    this._listenerCount = 0;\n    this._nativeEmitter.removeAllListeners(this._nativeEventName);\n  }\n  removeSubscription(subscription) {\n    this._listenerCount--;\n    this._nativeEmitter.removeSubscription(subscription);\n  }\n  setUpdateInterval(intervalMs) {\n    if (!this._nativeModule.setUpdateInterval) {\n      console.warn(\"expo-sensors: setUpdateInterval() is not supported on \".concat(Platform.OS));\n    } else {\n      this._nativeModule.setUpdateInterval(intervalMs);\n    }\n  }\n  isAvailableAsync() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (!_this._nativeModule.isAvailableAsync) {\n        return false;\n      } else {\n        return yield _this._nativeModule.isAvailableAsync();\n      }\n    })();\n  }\n}","map":{"version":3,"names":["EventEmitter","Platform","DeviceSensor","constructor","nativeSensorModule","nativeEventName","_nativeModule","_nativeEmitter","_nativeEventName","_listenerCount","addListener","listener","subscription","remove","removeSubscription","hasListeners","getListenerCount","removeAllListeners","setUpdateInterval","intervalMs","console","warn","concat","OS","isAvailableAsync","_this","_asyncToGenerator"],"sources":["/Users/zuyax/Developer/rn-starter/node_modules/expo-sensors/src/DeviceSensor.ts"],"sourcesContent":["import { EventEmitter, Subscription, Platform } from '@unimodules/core';\n\ntype Listener<E> = (event: E) => void;\n\ntype NativeSensorModule = any;\n\n/**\n * A base class for subscribable sensors. The events emitted by this class are measurements\n * specified by the parameter type `M`.\n */\nexport default class DeviceSensor<M> {\n  _nativeModule: NativeSensorModule;\n  _nativeEmitter: EventEmitter;\n  _nativeEventName: string;\n  _listenerCount: number;\n\n  constructor(nativeSensorModule: NativeSensorModule, nativeEventName: string) {\n    this._nativeModule = nativeSensorModule;\n    this._nativeEmitter = new EventEmitter(nativeSensorModule);\n    this._nativeEventName = nativeEventName;\n    this._listenerCount = 0;\n  }\n\n  addListener(listener: Listener<M>): Subscription {\n    let subscription = this._nativeEmitter.addListener(this._nativeEventName, listener);\n    subscription.remove = () => this.removeSubscription(subscription);\n    this._listenerCount++;\n    return subscription;\n  }\n\n  hasListeners(): boolean {\n    return this._listenerCount > 0;\n  }\n\n  getListenerCount(): number {\n    return this._listenerCount;\n  }\n\n  removeAllListeners(): void {\n    this._listenerCount = 0;\n    this._nativeEmitter.removeAllListeners(this._nativeEventName);\n  }\n\n  removeSubscription(subscription: Subscription): void {\n    this._listenerCount--;\n    this._nativeEmitter.removeSubscription(subscription);\n  }\n\n  setUpdateInterval(intervalMs: number): void {\n    if (!this._nativeModule.setUpdateInterval) {\n      console.warn(`expo-sensors: setUpdateInterval() is not supported on ${Platform.OS}`);\n    } else {\n      this._nativeModule.setUpdateInterval(intervalMs);\n    }\n  }\n  async isAvailableAsync(): Promise<boolean> {\n    if (!this._nativeModule.isAvailableAsync) {\n      return false;\n    } else {\n      return await this._nativeModule.isAvailableAsync();\n    }\n  }\n}\n"],"mappings":";;AAAA,SAASA,YAAY,EAAgBC,QAAQ,QAAQ,kBAAkB;AAUvE,eAAc,MAAOC,YAAY;EAM/BC,YAAYC,kBAAsC,EAAEC,eAAuB;IACzE,IAAI,CAACC,aAAa,GAAGF,kBAAkB;IACvC,IAAI,CAACG,cAAc,GAAG,IAAIP,YAAY,CAACI,kBAAkB,CAAC;IAC1D,IAAI,CAACI,gBAAgB,GAAGH,eAAe;IACvC,IAAI,CAACI,cAAc,GAAG,CAAC;EACzB;EAEAC,WAAWA,CAACC,QAAqB;IAC/B,IAAIC,YAAY,GAAG,IAAI,CAACL,cAAc,CAACG,WAAW,CAAC,IAAI,CAACF,gBAAgB,EAAEG,QAAQ,CAAC;IACnFC,YAAY,CAACC,MAAM,GAAG,MAAM,IAAI,CAACC,kBAAkB,CAACF,YAAY,CAAC;IACjE,IAAI,CAACH,cAAc,EAAE;IACrB,OAAOG,YAAY;EACrB;EAEAG,YAAYA,CAAA;IACV,OAAO,IAAI,CAACN,cAAc,GAAG,CAAC;EAChC;EAEAO,gBAAgBA,CAAA;IACd,OAAO,IAAI,CAACP,cAAc;EAC5B;EAEAQ,kBAAkBA,CAAA;IAChB,IAAI,CAACR,cAAc,GAAG,CAAC;IACvB,IAAI,CAACF,cAAc,CAACU,kBAAkB,CAAC,IAAI,CAACT,gBAAgB,CAAC;EAC/D;EAEAM,kBAAkBA,CAACF,YAA0B;IAC3C,IAAI,CAACH,cAAc,EAAE;IACrB,IAAI,CAACF,cAAc,CAACO,kBAAkB,CAACF,YAAY,CAAC;EACtD;EAEAM,iBAAiBA,CAACC,UAAkB;IAClC,IAAI,CAAC,IAAI,CAACb,aAAa,CAACY,iBAAiB,EAAE;MACzCE,OAAO,CAACC,IAAI,0DAAAC,MAAA,CAA0DrB,QAAQ,CAACsB,EAAE,CAAE,CAAC;KACrF,MAAM;MACL,IAAI,CAACjB,aAAa,CAACY,iBAAiB,CAACC,UAAU,CAAC;;EAEpD;EACMK,gBAAgBA,CAAA;IAAA,IAAAC,KAAA;IAAA,OAAAC,iBAAA;MACpB,IAAI,CAACD,KAAI,CAACnB,aAAa,CAACkB,gBAAgB,EAAE;QACxC,OAAO,KAAK;OACb,MAAM;QACL,aAAaC,KAAI,CAACnB,aAAa,CAACkB,gBAAgB,EAAE;;IACnD;EACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}