{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _objectSpread from \"@babel/runtime/helpers/objectSpread\";\nimport invariant from \"../utils/invariant\";\nimport getScreenForRouteName from \"./getScreenForRouteName\";\nimport createConfigGetter from \"./createConfigGetter\";\nimport * as NavigationActions from \"../NavigationActions\";\nimport * as SwitchActions from \"./SwitchActions\";\nimport validateRouteConfigMap from \"./validateRouteConfigMap\";\nimport { createPathParser } from \"./pathUtils\";\nvar defaultActionCreators = function defaultActionCreators() {\n  return {};\n};\nexport default (function (routeConfigs) {\n  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  validateRouteConfigMap(routeConfigs);\n  var order = config.order || Object.keys(routeConfigs);\n  var getCustomActionCreators = config.getCustomActionCreators || defaultActionCreators;\n  var initialRouteParams = config.initialRouteParams;\n  var initialRouteName = config.initialRouteName || order[0];\n  var backBehavior = config.backBehavior || 'none';\n  var resetOnBlur = config.hasOwnProperty('resetOnBlur') ? config.resetOnBlur : true;\n  var initialRouteIndex = order.indexOf(initialRouteName);\n  if (initialRouteIndex === -1) {\n    throw new Error(\"Invalid initialRouteName '\" + initialRouteName + \"'.\" + (\"Should be one of \" + order.map(function (n) {\n      return \"\\\"\" + n + \"\\\"\";\n    }).join(', ')));\n  }\n  var childRouters = {};\n  order.forEach(function (routeName) {\n    childRouters[routeName] = null;\n    var screen = getScreenForRouteName(routeConfigs, routeName);\n    if (screen.router) {\n      childRouters[routeName] = screen.router;\n    }\n  });\n  function getParamsForRoute(routeName, params) {\n    var routeConfig = routeConfigs[routeName];\n    if (routeConfig && routeConfig.params) {\n      return _objectSpread({}, routeConfig.params, params);\n    } else {\n      return params;\n    }\n  }\n  var _createPathParser = createPathParser(childRouters, routeConfigs, config),\n    getPathAndParamsForRoute = _createPathParser.getPathAndParamsForRoute,\n    _getActionForPathAndParams = _createPathParser.getActionForPathAndParams;\n  function resetChildRoute(routeName) {\n    var initialParams = routeName === initialRouteName ? initialRouteParams : undefined;\n    var params = getParamsForRoute(routeName, initialParams);\n    var childRouter = childRouters[routeName];\n    if (childRouter) {\n      var childAction = NavigationActions.init();\n      return _objectSpread({}, childRouter.getStateForAction(childAction), {\n        key: routeName,\n        routeName: routeName,\n        params: params\n      });\n    }\n    return {\n      key: routeName,\n      routeName: routeName,\n      params: params\n    };\n  }\n  function getNextState(action, prevState, possibleNextState) {\n    function updateNextStateHistory(nextState) {\n      if (backBehavior !== 'history') {\n        return nextState;\n      }\n      var nextRouteKeyHistory = prevState ? prevState.routeKeyHistory : [];\n      if (action.type === NavigationActions.NAVIGATE) {\n        nextRouteKeyHistory = _toConsumableArray(nextRouteKeyHistory);\n        var keyToAdd = nextState.routes[nextState.index].key;\n        nextRouteKeyHistory = nextRouteKeyHistory.filter(function (k) {\n          return k !== keyToAdd;\n        });\n        nextRouteKeyHistory.push(keyToAdd);\n      } else if (action.type === NavigationActions.BACK) {\n        nextRouteKeyHistory = _toConsumableArray(nextRouteKeyHistory);\n        nextRouteKeyHistory.pop();\n      }\n      return _objectSpread({}, nextState, {\n        routeKeyHistory: nextRouteKeyHistory\n      });\n    }\n    var nextState = possibleNextState;\n    if (prevState && prevState.index !== possibleNextState.index && resetOnBlur) {\n      var prevRouteName = prevState.routes[prevState.index].routeName;\n      var nextRoutes = _toConsumableArray(possibleNextState.routes);\n      nextRoutes[prevState.index] = resetChildRoute(prevRouteName);\n      nextState = _objectSpread({}, possibleNextState, {\n        routes: nextRoutes\n      });\n    }\n    return updateNextStateHistory(nextState);\n  }\n  function getInitialState() {\n    var routes = order.map(resetChildRoute);\n    var initialState = {\n      routes: routes,\n      index: initialRouteIndex,\n      isTransitioning: false\n    };\n    if (backBehavior === 'history') {\n      var initialKey = routes[initialRouteIndex].key;\n      initialState['routeKeyHistory'] = [initialKey];\n    }\n    return initialState;\n  }\n  return {\n    childRouters: childRouters,\n    getActionCreators: function getActionCreators(route, stateKey) {\n      return getCustomActionCreators(route, stateKey);\n    },\n    getStateForAction: function getStateForAction(action, inputState) {\n      var prevState = inputState ? _objectSpread({}, inputState) : inputState;\n      var state = inputState || getInitialState();\n      var activeChildIndex = state.index;\n      if (action.type === NavigationActions.INIT) {\n        var params = action.params;\n        if (params) {\n          state.routes = state.routes.map(function (route) {\n            return _objectSpread({}, route, {\n              params: _objectSpread({}, route.params, params, route.routeName === initialRouteName ? initialRouteParams : null)\n            });\n          });\n        }\n      }\n      if (action.type === SwitchActions.JUMP_TO && (action.key == null || action.key === state.key)) {\n        var _params = action.params;\n        var _index = state.routes.findIndex(function (route) {\n          return route.routeName === action.routeName;\n        });\n        if (_index === -1) {\n          throw new Error(\"There is no route named '\" + action.routeName + \"' in the navigator with the key '\" + action.key + \"'.\\n\" + (\"Must be one of: \" + state.routes.map(function (route) {\n            return \"'\" + route.routeName + \"'\";\n          }).join(',')));\n        }\n        return getNextState(action, prevState, _objectSpread({}, state, {\n          routes: state.routes.map(function (route, i) {\n            return i === _index ? _objectSpread({}, route, {\n              params: _objectSpread({}, route.params, _params)\n            }) : route;\n          }),\n          index: _index\n        }));\n      }\n      var activeChildLastState = state.routes[state.index];\n      var activeChildRouter = childRouters[order[state.index]];\n      if (activeChildRouter) {\n        var activeChildState = activeChildRouter.getStateForAction(action, activeChildLastState);\n        if (!activeChildState && inputState) {\n          return null;\n        }\n        if (activeChildState && activeChildState !== activeChildLastState) {\n          var _routes = _toConsumableArray(state.routes);\n          _routes[state.index] = activeChildState;\n          return getNextState(action, prevState, _objectSpread({}, state, {\n            routes: _routes\n          }));\n        }\n      }\n      var isBackEligible = action.key == null || action.key === activeChildLastState.key;\n      if (action.type === NavigationActions.BACK) {\n        if (isBackEligible && backBehavior === 'initialRoute') {\n          activeChildIndex = initialRouteIndex;\n        } else if (isBackEligible && backBehavior === 'order') {\n          activeChildIndex = Math.max(0, activeChildIndex - 1);\n        } else if (isBackEligible && backBehavior === 'history' && state.routeKeyHistory.length > 1) {\n          var routeKey = state.routeKeyHistory[state.routeKeyHistory.length - 2];\n          activeChildIndex = order.indexOf(routeKey);\n        } else {\n          return state;\n        }\n      }\n      var didNavigate = false;\n      if (action.type === NavigationActions.NAVIGATE) {\n        didNavigate = !!order.find(function (childId, i) {\n          if (childId === action.routeName) {\n            activeChildIndex = i;\n            return true;\n          }\n          return false;\n        });\n        if (didNavigate) {\n          var childState = state.routes[activeChildIndex];\n          var childRouter = childRouters[action.routeName];\n          var newChildState = childState;\n          if (action.action && childRouter) {\n            var childStateUpdate = childRouter.getStateForAction(action.action, childState);\n            if (childStateUpdate) {\n              newChildState = childStateUpdate;\n            }\n          }\n          if (action.params) {\n            newChildState = _objectSpread({}, newChildState, {\n              params: _objectSpread({}, newChildState.params || {}, action.params)\n            });\n          }\n          if (newChildState !== childState) {\n            var _routes2 = _toConsumableArray(state.routes);\n            _routes2[activeChildIndex] = newChildState;\n            var nextState = _objectSpread({}, state, {\n              routes: _routes2,\n              index: activeChildIndex\n            });\n            return getNextState(action, prevState, nextState);\n          } else if (newChildState === childState && state.index === activeChildIndex && prevState) {\n            return null;\n          }\n        }\n      }\n      if (action.type === NavigationActions.SET_PARAMS) {\n        var key = action.key;\n        var lastRoute = state.routes.find(function (route) {\n          return route.key === key;\n        });\n        if (lastRoute) {\n          var _params2 = _objectSpread({}, lastRoute.params, action.params);\n          var _routes3 = _toConsumableArray(state.routes);\n          _routes3[state.routes.indexOf(lastRoute)] = _objectSpread({}, lastRoute, {\n            params: _params2\n          });\n          return getNextState(action, prevState, _objectSpread({}, state, {\n            routes: _routes3\n          }));\n        }\n      }\n      if (activeChildIndex !== state.index) {\n        return getNextState(action, prevState, _objectSpread({}, state, {\n          index: activeChildIndex\n        }));\n      } else if (didNavigate && !inputState) {\n        return state;\n      } else if (didNavigate) {\n        return _objectSpread({}, state);\n      }\n      var index = state.index;\n      var routes = state.routes;\n      order.find(function (childId, i) {\n        var childRouter = childRouters[childId];\n        if (i === index) {\n          return false;\n        }\n        var childState = routes[i];\n        if (childRouter) {\n          childState = childRouter.getStateForAction(action, childState);\n        }\n        if (!childState) {\n          index = i;\n          return true;\n        }\n        if (childState !== routes[i]) {\n          routes = _toConsumableArray(routes);\n          routes[i] = childState;\n          index = i;\n          return true;\n        }\n        return false;\n      });\n      if (action.preserveFocus) {\n        index = state.index;\n      }\n      if (index !== state.index || routes !== state.routes) {\n        return getNextState(action, prevState, _objectSpread({}, state, {\n          index: index,\n          routes: routes\n        }));\n      }\n      return state;\n    },\n    getComponentForState: function getComponentForState(state) {\n      var routeName = state.routes[state.index].routeName;\n      invariant(routeName, \"There is no route defined for index \" + state.index + \". Check that\\n        that you passed in a navigation state with a valid tab/screen index.\");\n      var childRouter = childRouters[routeName];\n      if (childRouter) {\n        return childRouter.getComponentForState(state.routes[state.index]);\n      }\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n    getComponentForRouteName: function getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n    getPathAndParamsForState: function getPathAndParamsForState(state) {\n      var route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n    getActionForPathAndParams: function getActionForPathAndParams(path, params) {\n      return _getActionForPathAndParams(path, params);\n    },\n    getScreenOptions: createConfigGetter(routeConfigs, config.defaultNavigationOptions)\n  };\n});","map":{"version":3,"names":["invariant","getScreenForRouteName","createConfigGetter","NavigationActions","SwitchActions","validateRouteConfigMap","createPathParser","defaultActionCreators","routeConfigs","config","arguments","length","undefined","order","Object","keys","getCustomActionCreators","initialRouteParams","initialRouteName","backBehavior","resetOnBlur","hasOwnProperty","initialRouteIndex","indexOf","Error","map","n","join","childRouters","forEach","routeName","screen","router","getParamsForRoute","params","routeConfig","_objectSpread","_createPathParser","getPathAndParamsForRoute","_getActionForPathAndParams","getActionForPathAndParams","resetChildRoute","initialParams","childRouter","childAction","init","getStateForAction","key","getNextState","action","prevState","possibleNextState","updateNextStateHistory","nextState","nextRouteKeyHistory","routeKeyHistory","type","NAVIGATE","_toConsumableArray","keyToAdd","routes","index","filter","k","push","BACK","pop","prevRouteName","nextRoutes","getInitialState","initialState","isTransitioning","initialKey","getActionCreators","route","stateKey","inputState","state","activeChildIndex","INIT","JUMP_TO","_params","_index","findIndex","i","activeChildLastState","activeChildRouter","activeChildState","_routes","isBackEligible","Math","max","routeKey","didNavigate","find","childId","childState","newChildState","childStateUpdate","_routes2","SET_PARAMS","lastRoute","_params2","_routes3","preserveFocus","getComponentForState","getComponentForRouteName","getPathAndParamsForState","path","getScreenOptions","defaultNavigationOptions"],"sources":["/Users/zuyax/Developer/rn-starter/node_modules/@react-navigation/core/lib/module/routers/SwitchRouter.js"],"sourcesContent":["import invariant from '../utils/invariant';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport createConfigGetter from './createConfigGetter';\n\nimport * as NavigationActions from '../NavigationActions';\nimport * as SwitchActions from './SwitchActions';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport { createPathParser } from './pathUtils';\n\nconst defaultActionCreators = () => ({});\n\nexport default (routeConfigs, config = {}) => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n\n  const order = config.order || Object.keys(routeConfigs);\n\n  const getCustomActionCreators =\n    config.getCustomActionCreators || defaultActionCreators;\n\n  const initialRouteParams = config.initialRouteParams;\n  const initialRouteName = config.initialRouteName || order[0];\n  const backBehavior = config.backBehavior || 'none';\n  const resetOnBlur = config.hasOwnProperty('resetOnBlur')\n    ? config.resetOnBlur\n    : true;\n\n  const initialRouteIndex = order.indexOf(initialRouteName);\n  if (initialRouteIndex === -1) {\n    throw new Error(\n      `Invalid initialRouteName '${initialRouteName}'.` +\n        `Should be one of ${order.map(n => `\"${n}\"`).join(', ')}`\n    );\n  }\n\n  const childRouters = {};\n  order.forEach(routeName => {\n    childRouters[routeName] = null;\n    const screen = getScreenForRouteName(routeConfigs, routeName);\n    if (screen.router) {\n      childRouters[routeName] = screen.router;\n    }\n  });\n\n  function getParamsForRoute(routeName, params) {\n    let routeConfig = routeConfigs[routeName];\n    if (routeConfig && routeConfig.params) {\n      return { ...routeConfig.params, ...params };\n    } else {\n      return params;\n    }\n  }\n\n  const {\n    getPathAndParamsForRoute,\n    getActionForPathAndParams,\n  } = createPathParser(childRouters, routeConfigs, config);\n\n  function resetChildRoute(routeName) {\n    let initialParams =\n      routeName === initialRouteName ? initialRouteParams : undefined;\n    // note(brentvatne): merging initialRouteParams *on top* of default params\n    // on the route seems incorrect but it's consistent with existing behavior\n    // in stackrouter\n    let params = getParamsForRoute(routeName, initialParams);\n    const childRouter = childRouters[routeName];\n    if (childRouter) {\n      const childAction = NavigationActions.init();\n      return {\n        ...childRouter.getStateForAction(childAction),\n        key: routeName,\n        routeName,\n        params,\n      };\n    }\n    return {\n      key: routeName,\n      routeName,\n      params,\n    };\n  }\n\n  function getNextState(action, prevState, possibleNextState) {\n    function updateNextStateHistory(nextState) {\n      if (backBehavior !== 'history') {\n        return nextState;\n      }\n      let nextRouteKeyHistory = prevState ? prevState.routeKeyHistory : [];\n      if (action.type === NavigationActions.NAVIGATE) {\n        nextRouteKeyHistory = [...nextRouteKeyHistory]; // copy\n        const keyToAdd = nextState.routes[nextState.index].key;\n        nextRouteKeyHistory = nextRouteKeyHistory.filter(k => k !== keyToAdd); // dedup\n        nextRouteKeyHistory.push(keyToAdd);\n      } else if (action.type === NavigationActions.BACK) {\n        nextRouteKeyHistory = [...nextRouteKeyHistory]; // copy\n        nextRouteKeyHistory.pop();\n      }\n      return {\n        ...nextState,\n        routeKeyHistory: nextRouteKeyHistory,\n      };\n    }\n\n    let nextState = possibleNextState;\n    if (\n      prevState &&\n      prevState.index !== possibleNextState.index &&\n      resetOnBlur\n    ) {\n      const prevRouteName = prevState.routes[prevState.index].routeName;\n      const nextRoutes = [...possibleNextState.routes];\n      nextRoutes[prevState.index] = resetChildRoute(prevRouteName);\n      nextState = {\n        ...possibleNextState,\n        routes: nextRoutes,\n      };\n    }\n    return updateNextStateHistory(nextState);\n  }\n\n  function getInitialState() {\n    const routes = order.map(resetChildRoute);\n    const initialState = {\n      routes,\n      index: initialRouteIndex,\n      isTransitioning: false,\n    };\n    if (backBehavior === 'history') {\n      const initialKey = routes[initialRouteIndex].key;\n      initialState['routeKeyHistory'] = [initialKey];\n    }\n    return initialState;\n  }\n\n  return {\n    childRouters,\n\n    getActionCreators(route, stateKey) {\n      return getCustomActionCreators(route, stateKey);\n    },\n\n    getStateForAction(action, inputState) {\n      let prevState = inputState ? { ...inputState } : inputState;\n      let state = inputState || getInitialState();\n      let activeChildIndex = state.index;\n\n      if (action.type === NavigationActions.INIT) {\n        // NOTE(brentvatne): this seems weird... why are we merging these\n        // params into child routes?\n        // ---------------------------------------------------------------\n        // Merge any params from the action into all the child routes\n        const { params } = action;\n        if (params) {\n          state.routes = state.routes.map(route => ({\n            ...route,\n            params: {\n              ...route.params,\n              ...params,\n              ...(route.routeName === initialRouteName\n                ? initialRouteParams\n                : null),\n            },\n          }));\n        }\n      }\n\n      if (\n        action.type === SwitchActions.JUMP_TO &&\n        (action.key == null || action.key === state.key)\n      ) {\n        const { params } = action;\n        const index = state.routes.findIndex(\n          route => route.routeName === action.routeName\n        );\n\n        if (index === -1) {\n          throw new Error(\n            `There is no route named '${\n              action.routeName\n            }' in the navigator with the key '${action.key}'.\\n` +\n              `Must be one of: ${state.routes\n                .map(route => `'${route.routeName}'`)\n                .join(',')}`\n          );\n        }\n\n        return getNextState(action, prevState, {\n          ...state,\n          routes: state.routes.map((route, i) =>\n            i === index\n              ? {\n                  ...route,\n                  params: {\n                    ...route.params,\n                    ...params,\n                  },\n                }\n              : route\n          ),\n          index,\n        });\n      }\n\n      // Let the current child handle it\n      const activeChildLastState = state.routes[state.index];\n      const activeChildRouter = childRouters[order[state.index]];\n      if (activeChildRouter) {\n        const activeChildState = activeChildRouter.getStateForAction(\n          action,\n          activeChildLastState\n        );\n        if (!activeChildState && inputState) {\n          return null;\n        }\n        if (activeChildState && activeChildState !== activeChildLastState) {\n          const routes = [...state.routes];\n          routes[state.index] = activeChildState;\n          return getNextState(action, prevState, {\n            ...state,\n            routes,\n          });\n        }\n      }\n\n      // Handle tab changing. Do this after letting the current tab try to\n      // handle the action, to allow inner children to change first\n      const isBackEligible =\n        action.key == null || action.key === activeChildLastState.key;\n      if (action.type === NavigationActions.BACK) {\n        if (isBackEligible && backBehavior === 'initialRoute') {\n          activeChildIndex = initialRouteIndex;\n        } else if (isBackEligible && backBehavior === 'order') {\n          activeChildIndex = Math.max(0, activeChildIndex - 1);\n        }\n        // The history contains current route, so we can only go back\n        // if there is more than one item in the history\n        else if (\n          isBackEligible &&\n          backBehavior === 'history' &&\n          state.routeKeyHistory.length > 1\n        ) {\n          const routeKey =\n            state.routeKeyHistory[state.routeKeyHistory.length - 2];\n          activeChildIndex = order.indexOf(routeKey);\n        } else {\n          return state;\n        }\n      }\n\n      let didNavigate = false;\n      if (action.type === NavigationActions.NAVIGATE) {\n        didNavigate = !!order.find((childId, i) => {\n          if (childId === action.routeName) {\n            activeChildIndex = i;\n            return true;\n          }\n          return false;\n        });\n        if (didNavigate) {\n          const childState = state.routes[activeChildIndex];\n          const childRouter = childRouters[action.routeName];\n          let newChildState = childState;\n\n          if (action.action && childRouter) {\n            const childStateUpdate = childRouter.getStateForAction(\n              action.action,\n              childState\n            );\n            if (childStateUpdate) {\n              newChildState = childStateUpdate;\n            }\n          }\n\n          if (action.params) {\n            newChildState = {\n              ...newChildState,\n              params: {\n                ...(newChildState.params || {}),\n                ...action.params,\n              },\n            };\n          }\n\n          if (newChildState !== childState) {\n            const routes = [...state.routes];\n            routes[activeChildIndex] = newChildState;\n            const nextState = {\n              ...state,\n              routes,\n              index: activeChildIndex,\n            };\n            return getNextState(action, prevState, nextState);\n          } else if (\n            newChildState === childState &&\n            state.index === activeChildIndex &&\n            prevState\n          ) {\n            return null;\n          }\n        }\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find(route => route.key === key);\n        if (lastRoute) {\n          const params = {\n            ...lastRoute.params,\n            ...action.params,\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = {\n            ...lastRoute,\n            params,\n          };\n          return getNextState(action, prevState, {\n            ...state,\n            routes,\n          });\n        }\n      }\n\n      if (activeChildIndex !== state.index) {\n        return getNextState(action, prevState, {\n          ...state,\n          index: activeChildIndex,\n        });\n      } else if (didNavigate && !inputState) {\n        return state;\n      } else if (didNavigate) {\n        return { ...state };\n      }\n\n      // Let other children handle it and switch to the first child that returns a new state\n      let index = state.index;\n      let routes = state.routes;\n      order.find((childId, i) => {\n        const childRouter = childRouters[childId];\n        if (i === index) {\n          return false;\n        }\n        let childState = routes[i];\n        if (childRouter) {\n          childState = childRouter.getStateForAction(action, childState);\n        }\n        if (!childState) {\n          index = i;\n          return true;\n        }\n        if (childState !== routes[i]) {\n          routes = [...routes];\n          routes[i] = childState;\n          index = i;\n          return true;\n        }\n        return false;\n      });\n\n      // Nested routers can be updated after switching children with actions such as SET_PARAMS\n      // and COMPLETE_TRANSITION.\n      if (action.preserveFocus) {\n        index = state.index;\n      }\n\n      if (index !== state.index || routes !== state.routes) {\n        return getNextState(action, prevState, {\n          ...state,\n          index,\n          routes,\n        });\n      }\n      return state;\n    },\n\n    getComponentForState(state) {\n      const routeName = state.routes[state.index].routeName;\n      invariant(\n        routeName,\n        `There is no route defined for index ${state.index}. Check that\n        that you passed in a navigation state with a valid tab/screen index.`\n      );\n      const childRouter = childRouters[routeName];\n      if (childRouter) {\n        return childRouter.getComponentForState(state.routes[state.index]);\n      }\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getPathAndParamsForState(state) {\n      const route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n\n    getActionForPathAndParams(path, params) {\n      return getActionForPathAndParams(path, params);\n    },\n\n    getScreenOptions: createConfigGetter(\n      routeConfigs,\n      config.defaultNavigationOptions\n    ),\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}