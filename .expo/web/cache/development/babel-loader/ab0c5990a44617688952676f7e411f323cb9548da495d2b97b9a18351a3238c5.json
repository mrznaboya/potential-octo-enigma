{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/objectSpread\";\nimport getChildEventSubscriber from \"./getChildEventSubscriber\";\nimport getChildRouter from \"./getChildRouter\";\nimport getNavigationActionCreators from \"./routers/getNavigationActionCreators\";\nimport getChildrenNavigationCache from \"./getChildrenNavigationCache\";\nvar createParamGetter = function createParamGetter(route) {\n  return function (paramName, defaultValue) {\n    var params = route.params;\n    if (params && paramName in params) {\n      return params[paramName];\n    }\n    return defaultValue;\n  };\n};\nfunction _getChildNavigation(navigation, childKey, getCurrentParentNavigation) {\n  var children = getChildrenNavigationCache(navigation);\n  var childRoute = navigation.state.routes.find(function (r) {\n    return r.key === childKey;\n  });\n  if (!childRoute) {\n    return null;\n  }\n  if (children[childKey] && children[childKey].state === childRoute) {\n    return children[childKey];\n  }\n  var childRouter = getChildRouter(navigation.router, childRoute.routeName);\n  var focusedGrandChildRoute = childRoute.routes && typeof childRoute.index === 'number' ? childRoute.routes[childRoute.index] : null;\n  var actionCreators = _objectSpread({}, navigation.actions, navigation.router.getActionCreators(childRoute, navigation.state.key), childRouter ? childRouter.getActionCreators(focusedGrandChildRoute, childRoute.key) : {}, getNavigationActionCreators(childRoute));\n  var actionHelpers = {};\n  Object.keys(actionCreators).forEach(function (actionName) {\n    actionHelpers[actionName] = function () {\n      var actionCreator = actionCreators[actionName];\n      var action = actionCreator.apply(void 0, arguments);\n      return navigation.dispatch(action);\n    };\n  });\n  var _isFirstRouteInParent = true;\n  var parentNavigation = getCurrentParentNavigation();\n  if (parentNavigation) {\n    _isFirstRouteInParent = parentNavigation.state.routes.indexOf(childRoute) === 0;\n  }\n  if (children[childKey] && children[childKey].isFirstRouteInParent() === _isFirstRouteInParent) {\n    children[childKey] = _objectSpread({}, children[childKey], actionHelpers, {\n      state: childRoute,\n      router: childRouter,\n      actions: actionCreators,\n      getParam: createParamGetter(childRoute)\n    });\n    return children[childKey];\n  } else {\n    var childSubscriber = getChildEventSubscriber(navigation.addListener, childKey);\n    children[childKey] = _objectSpread({}, actionHelpers, {\n      state: childRoute,\n      router: childRouter,\n      actions: actionCreators,\n      getParam: createParamGetter(childRoute),\n      getChildNavigation: function getChildNavigation(grandChildKey) {\n        return _getChildNavigation(children[childKey], grandChildKey, function () {\n          var nav = getCurrentParentNavigation();\n          return nav && nav.getChildNavigation(childKey);\n        });\n      },\n      isFocused: function isFocused() {\n        var currentNavigation = getCurrentParentNavigation();\n        if (!currentNavigation) {\n          return false;\n        }\n        var _currentNavigation$st = currentNavigation.state,\n          routes = _currentNavigation$st.routes,\n          index = _currentNavigation$st.index;\n        if (!currentNavigation.isFocused()) {\n          return false;\n        }\n        if (routes[index].key === childKey) {\n          return true;\n        }\n        return false;\n      },\n      isFirstRouteInParent: function isFirstRouteInParent() {\n        return _isFirstRouteInParent;\n      },\n      dispatch: navigation.dispatch,\n      getScreenProps: navigation.getScreenProps,\n      dangerouslyGetParent: getCurrentParentNavigation,\n      addListener: childSubscriber.addListener,\n      emit: childSubscriber.emit\n    });\n    return children[childKey];\n  }\n}\nexport default _getChildNavigation;","map":{"version":3,"names":["getChildEventSubscriber","getChildRouter","getNavigationActionCreators","getChildrenNavigationCache","createParamGetter","route","paramName","defaultValue","params","_getChildNavigation","getChildNavigation","navigation","childKey","getCurrentParentNavigation","children","childRoute","state","routes","find","r","key","childRouter","router","routeName","focusedGrandChildRoute","index","actionCreators","_objectSpread","actions","getActionCreators","actionHelpers","Object","keys","forEach","actionName","actionCreator","action","apply","arguments","dispatch","_isFirstRouteInParent","parentNavigation","indexOf","isFirstRouteInParent","getParam","childSubscriber","addListener","grandChildKey","nav","isFocused","currentNavigation","_currentNavigation$st","getScreenProps","dangerouslyGetParent","emit"],"sources":["/Users/zuyax/Developer/rn-starter/node_modules/@react-navigation/core/lib/module/getChildNavigation.js"],"sourcesContent":["import getChildEventSubscriber from './getChildEventSubscriber';\nimport getChildRouter from './getChildRouter';\nimport getNavigationActionCreators from './routers/getNavigationActionCreators';\nimport getChildrenNavigationCache from './getChildrenNavigationCache';\n\nconst createParamGetter = route => (paramName, defaultValue) => {\n  const params = route.params;\n\n  if (params && paramName in params) {\n    return params[paramName];\n  }\n\n  return defaultValue;\n};\n\nfunction getChildNavigation(navigation, childKey, getCurrentParentNavigation) {\n  const children = getChildrenNavigationCache(navigation);\n  const childRoute = navigation.state.routes.find(r => r.key === childKey);\n\n  if (!childRoute) {\n    return null;\n  }\n\n  if (children[childKey] && children[childKey].state === childRoute) {\n    return children[childKey];\n  }\n\n  const childRouter = getChildRouter(navigation.router, childRoute.routeName);\n\n  // If the route has children, we'll use this to pass in to the action creators\n  // for the childRouter so that any action that depends on the active route will\n  // behave as expected. We don't explicitly require that routers implement routes\n  // and index properties, but if we did then we would put an invariant here to\n  // ensure that a focusedGrandChildRoute exists if childRouter is defined.\n  const focusedGrandChildRoute =\n    childRoute.routes && typeof childRoute.index === 'number'\n      ? childRoute.routes[childRoute.index]\n      : null;\n\n  const actionCreators = {\n    ...navigation.actions,\n    ...navigation.router.getActionCreators(childRoute, navigation.state.key),\n    ...(childRouter\n      ? childRouter.getActionCreators(focusedGrandChildRoute, childRoute.key)\n      : {}),\n    ...getNavigationActionCreators(childRoute),\n  };\n\n  const actionHelpers = {};\n  Object.keys(actionCreators).forEach(actionName => {\n    actionHelpers[actionName] = (...args) => {\n      const actionCreator = actionCreators[actionName];\n      const action = actionCreator(...args);\n      return navigation.dispatch(action);\n    };\n  });\n\n  let isFirstRouteInParent = true;\n\n  const parentNavigation = getCurrentParentNavigation();\n\n  if (parentNavigation) {\n    isFirstRouteInParent =\n      parentNavigation.state.routes.indexOf(childRoute) === 0;\n  }\n\n  if (\n    children[childKey] &&\n    children[childKey].isFirstRouteInParent() === isFirstRouteInParent\n  ) {\n    children[childKey] = {\n      ...children[childKey],\n      ...actionHelpers,\n      state: childRoute,\n      router: childRouter,\n      actions: actionCreators,\n      getParam: createParamGetter(childRoute),\n    };\n    return children[childKey];\n  } else {\n    const childSubscriber = getChildEventSubscriber(\n      navigation.addListener,\n      childKey\n    );\n\n    children[childKey] = {\n      ...actionHelpers,\n\n      state: childRoute,\n      router: childRouter,\n      actions: actionCreators,\n      getParam: createParamGetter(childRoute),\n\n      getChildNavigation: grandChildKey =>\n        getChildNavigation(children[childKey], grandChildKey, () => {\n          const nav = getCurrentParentNavigation();\n          return nav && nav.getChildNavigation(childKey);\n        }),\n\n      isFocused: () => {\n        const currentNavigation = getCurrentParentNavigation();\n        if (!currentNavigation) {\n          return false;\n        }\n        const { routes, index } = currentNavigation.state;\n        if (!currentNavigation.isFocused()) {\n          return false;\n        }\n        if (routes[index].key === childKey) {\n          return true;\n        }\n        return false;\n      },\n      isFirstRouteInParent: () => isFirstRouteInParent,\n      dispatch: navigation.dispatch,\n      getScreenProps: navigation.getScreenProps,\n      dangerouslyGetParent: getCurrentParentNavigation,\n      addListener: childSubscriber.addListener,\n      emit: childSubscriber.emit,\n    };\n    return children[childKey];\n  }\n}\n\nexport default getChildNavigation;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}