{"ast":null,"code":"function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nimport { UnavailabilityError } from '@unimodules/core';\nimport ExpoCrypto from \"./ExpoCrypto\";\nimport { CryptoDigestAlgorithm, CryptoEncoding } from \"./Crypto.types\";\nexport * from \"./Crypto.types\";\nclass CryptoError extends TypeError {\n  constructor(message) {\n    super(\"expo-crypto: \".concat(message));\n    this.code = 'ERR_CRYPTO';\n  }\n}\nfunction assertAlgorithm(algorithm) {\n  if (!Object.values(CryptoDigestAlgorithm).includes(algorithm)) {\n    throw new CryptoError(\"Invalid algorithm provided. Expected one of: CryptoDigestAlgorithm.\".concat(Object.keys(CryptoDigestAlgorithm).join(', AlgCryptoDigestAlgorithmorithm.')));\n  }\n}\nfunction assertData(data) {\n  if (typeof data !== 'string') {\n    throw new CryptoError(\"Invalid data provided. Expected a string.\");\n  }\n}\nfunction assertEncoding(encoding) {\n  if (!Object.values(CryptoEncoding).includes(encoding)) {\n    throw new CryptoError(\"Invalid encoding provided. Expected one of: CryptoEncoding.\".concat(Object.keys(CryptoEncoding).join(', CryptoEncoding.')));\n  }\n}\nexport function digestStringAsync(_x, _x2) {\n  return _digestStringAsync.apply(this, arguments);\n}\nfunction _digestStringAsync() {\n  _digestStringAsync = _asyncToGenerator(function* (algorithm, data) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      encoding: CryptoEncoding.HEX\n    };\n    if (!ExpoCrypto.digestStringAsync) {\n      throw new UnavailabilityError('expo-crypto', 'digestStringAsync');\n    }\n    assertAlgorithm(algorithm);\n    assertData(data);\n    assertEncoding(options.encoding);\n    return yield ExpoCrypto.digestStringAsync(algorithm, data, options);\n  });\n  return _digestStringAsync.apply(this, arguments);\n}","map":{"version":3,"names":["UnavailabilityError","ExpoCrypto","CryptoDigestAlgorithm","CryptoEncoding","CryptoError","TypeError","constructor","message","concat","code","assertAlgorithm","algorithm","Object","values","includes","keys","join","assertData","data","assertEncoding","encoding","digestStringAsync","_x","_x2","_digestStringAsync","apply","arguments","_asyncToGenerator","options","length","undefined","HEX"],"sources":["/Users/zuyax/Developer/rn-starter/node_modules/expo-crypto/src/Crypto.ts"],"sourcesContent":["import { UnavailabilityError } from '@unimodules/core';\nimport ExpoCrypto from './ExpoCrypto';\n\nimport { CryptoDigestAlgorithm, CryptoEncoding, CryptoDigestOptions, Digest } from './Crypto.types';\nexport * from './Crypto.types';\n\nclass CryptoError extends TypeError {\n  code = 'ERR_CRYPTO';\n\n  constructor(message: string) {\n    super(`expo-crypto: ${message}`);\n  }\n}\n\nfunction assertAlgorithm(algorithm: CryptoDigestAlgorithm): void {\n  if (!Object.values(CryptoDigestAlgorithm).includes(algorithm)) {\n    throw new CryptoError(\n      `Invalid algorithm provided. Expected one of: CryptoDigestAlgorithm.${Object.keys(\n        CryptoDigestAlgorithm\n      ).join(', AlgCryptoDigestAlgorithmorithm.')}`\n    );\n  }\n}\n\nfunction assertData(data: string): void {\n  if (typeof data !== 'string') {\n    throw new CryptoError(`Invalid data provided. Expected a string.`);\n  }\n}\n\nfunction assertEncoding(encoding: CryptoEncoding): void {\n  if (!Object.values(CryptoEncoding).includes(encoding)) {\n    throw new CryptoError(\n      `Invalid encoding provided. Expected one of: CryptoEncoding.${Object.keys(\n        CryptoEncoding\n      ).join(', CryptoEncoding.')}`\n    );\n  }\n}\n\nexport async function digestStringAsync(\n  algorithm: CryptoDigestAlgorithm,\n  data: string,\n  options: CryptoDigestOptions = { encoding: CryptoEncoding.HEX }\n): Promise<Digest> {\n  if (!ExpoCrypto.digestStringAsync) {\n    throw new UnavailabilityError('expo-crypto', 'digestStringAsync');\n  }\n\n  assertAlgorithm(algorithm);\n  assertData(data);\n  assertEncoding(options.encoding);\n\n  return await ExpoCrypto.digestStringAsync(algorithm, data, options);\n}\n"],"mappings":";;AAAA,SAASA,mBAAmB,QAAQ,kBAAkB;AACtD,OAAOC,UAAU;AAEjB,SAASC,qBAAqB,EAAEC,cAAc;AAC9C;AAEA,MAAMC,WAAY,SAAQC,SAAS;EAGjCC,YAAYC,OAAe;IACzB,KAAK,iBAAAC,MAAA,CAAiBD,OAAO,CAAE,CAAC;IAHlC,KAAAE,IAAI,GAAG,YAAY;EAInB;;AAGF,SAASC,eAAeA,CAACC,SAAgC;EACvD,IAAI,CAACC,MAAM,CAACC,MAAM,CAACX,qBAAqB,CAAC,CAACY,QAAQ,CAACH,SAAS,CAAC,EAAE;IAC7D,MAAM,IAAIP,WAAW,uEAAAI,MAAA,CACmDI,MAAM,CAACG,IAAI,CAC/Eb,qBAAqB,CACtB,CAACc,IAAI,CAAC,mCAAmC,CAAC,CAAE,CAC9C;;AAEL;AAEA,SAASC,UAAUA,CAACC,IAAY;EAC9B,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;IAC5B,MAAM,IAAId,WAAW,4CAA4C,CAAC;;AAEtE;AAEA,SAASe,cAAcA,CAACC,QAAwB;EAC9C,IAAI,CAACR,MAAM,CAACC,MAAM,CAACV,cAAc,CAAC,CAACW,QAAQ,CAACM,QAAQ,CAAC,EAAE;IACrD,MAAM,IAAIhB,WAAW,+DAAAI,MAAA,CAC2CI,MAAM,CAACG,IAAI,CACvEZ,cAAc,CACf,CAACa,IAAI,CAAC,mBAAmB,CAAC,CAAE,CAC9B;;AAEL;AAEA,gBAAsBK,iBAAiBA,CAAAC,EAAA,EAAAC,GAAA;EAAA,OAAAC,kBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AActC,SAAAF,mBAAA;EAAAA,kBAAA,GAAAG,iBAAA,CAdM,WACLhB,SAAgC,EAChCO,IAAY,EACmD;IAAA,IAA/DU,OAAA,GAAAF,SAAA,CAAAG,MAAA,QAAAH,SAAA,QAAAI,SAAA,GAAAJ,SAAA,MAA+B;MAAEN,QAAQ,EAAEjB,cAAc,CAAC4B;IAAG,CAAE;IAE/D,IAAI,CAAC9B,UAAU,CAACoB,iBAAiB,EAAE;MACjC,MAAM,IAAIrB,mBAAmB,CAAC,aAAa,EAAE,mBAAmB,CAAC;;IAGnEU,eAAe,CAACC,SAAS,CAAC;IAC1BM,UAAU,CAACC,IAAI,CAAC;IAChBC,cAAc,CAACS,OAAO,CAACR,QAAQ,CAAC;IAEhC,aAAanB,UAAU,CAACoB,iBAAiB,CAACV,SAAS,EAAEO,IAAI,EAAEU,OAAO,CAAC;EACrE,CAAC;EAAA,OAAAJ,kBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}