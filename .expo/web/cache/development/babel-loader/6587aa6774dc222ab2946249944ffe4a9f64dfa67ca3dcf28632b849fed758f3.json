{"ast":null,"code":"var _jsxFileName = \"/Users/zuyax/Developer/rn-starter/node_modules/@react-navigation/native/dist/createAppContainer.js\";\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nimport React from 'react';\nimport Linking from \"react-native-web/dist/exports/Linking\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport BackHandler from \"react-native-web/dist/exports/BackHandler\";\nimport { NavigationActions, pathUtils, getNavigation, NavigationProvider } from '@react-navigation/core';\nimport invariant from \"./utils/invariant\";\nimport docsUrl from \"./utils/docsUrl\";\nvar {\n  urlToPathAndParams\n} = pathUtils;\nfunction isStateful(props) {\n  return !props.navigation;\n}\nfunction validateProps(props) {\n  if (props.persistenceKey) {\n    console.warn('You passed persistenceKey prop to a navigator. ' + 'The persistenceKey prop was replaced by a more flexible persistence mechanism, ' + 'please see the navigation state persistence docs for more information. ' + 'Passing the persistenceKey prop is a no-op.');\n  }\n  if (isStateful(props)) {\n    return;\n  }\n  var {\n      navigation,\n      screenProps,\n      persistNavigationState,\n      loadNavigationState\n    } = props,\n    containerProps = _objectWithoutProperties(props, [\"navigation\", \"screenProps\", \"persistNavigationState\", \"loadNavigationState\"]);\n  var keys = Object.keys(containerProps);\n  if (keys.length !== 0) {\n    throw new Error('This navigator has both navigation and container props, so it is ' + \"unclear if it should own its own state. Remove props: \\\"\".concat(keys.join(', '), \"\\\" \") + 'if the navigator should get its state from the navigation prop. If the ' + 'navigator should maintain its own state, do not pass a navigation prop.');\n  }\n  invariant(persistNavigationState === undefined && loadNavigationState === undefined || typeof persistNavigationState === 'function' && typeof loadNavigationState === 'function', 'both persistNavigationState and loadNavigationState must either be undefined, or be functions');\n}\nvar _statefulContainerCount = 0;\nexport function _TESTING_ONLY_reset_container_count() {\n  _statefulContainerCount = 0;\n}\nvar _reactNavigationIsHydratingState = false;\nexport default function createNavigationContainer(Component) {\n  class NavigationContainer extends React.Component {\n    static getDerivedStateFromProps(nextProps) {\n      validateProps(nextProps);\n      return null;\n    }\n    constructor(props) {\n      var _this;\n      super(props);\n      _this = this;\n      this.subs = null;\n      this._actionEventSubscribers = new Set();\n      this._handleOpenURL = _ref => {\n        var {\n          url\n        } = _ref;\n        var {\n          enableURLHandling,\n          uriPrefix\n        } = this.props;\n        if (enableURLHandling === false) {\n          return;\n        }\n        var parsedUrl = urlToPathAndParams(url, uriPrefix);\n        if (parsedUrl) {\n          var {\n            path,\n            params\n          } = parsedUrl;\n          var action = Component.router.getActionForPathAndParams(path, params);\n          if (action) {\n            this.dispatch(action);\n          }\n        }\n      };\n      this._persistNavigationState = function () {\n        var _ref2 = _asyncToGenerator(function* (nav) {\n          var {\n            persistNavigationState\n          } = _this.props;\n          if (persistNavigationState) {\n            try {\n              yield persistNavigationState(nav);\n            } catch (err) {\n              console.warn('Uncaught exception while calling persistNavigationState()! You should handle exceptions thrown from persistNavigationState(), ignoring them may result in undefined behavior.');\n            }\n          }\n        });\n        return function (_x) {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n      this.dispatch = action => {\n        if (this.props.navigation) {\n          return this.props.navigation.dispatch(action);\n        }\n        this._navState = this._navState || this.state.nav;\n        var lastNavState = this._navState;\n        invariant(lastNavState, 'should be set in constructor if stateful');\n        var reducedState = Component.router.getStateForAction(action, lastNavState);\n        var navState = reducedState === null ? lastNavState : reducedState;\n        var dispatchActionEvents = () => {\n          this._actionEventSubscribers.forEach(subscriber => subscriber({\n            type: 'action',\n            action,\n            state: navState,\n            lastState: lastNavState\n          }));\n        };\n        if (reducedState === null) {\n          dispatchActionEvents();\n          return true;\n        }\n        if (navState !== lastNavState) {\n          this._navState = navState;\n          this.setState({\n            nav: navState\n          }, () => {\n            this._onNavigationStateChange(lastNavState, navState, action);\n            dispatchActionEvents();\n            this._persistNavigationState(navState);\n          });\n          return true;\n        }\n        dispatchActionEvents();\n        return false;\n      };\n      this._getScreenProps = () => this.props.screenProps;\n      validateProps(props);\n      this._initialAction = NavigationActions.init();\n      if (this._isStateful() && BackHandler && typeof BackHandler.addEventListener === 'function') {\n        this.subs = BackHandler.addEventListener('hardwareBackPress', () => {\n          if (!this._isMounted) {\n            this.subs && this.subs.remove();\n          } else {\n            return this.dispatch(NavigationActions.back());\n          }\n        });\n      }\n      this.state = {\n        nav: this._isStateful() && !props.loadNavigationState ? Component.router.getStateForAction(this._initialAction) : null\n      };\n    }\n    _renderLoading() {\n      return this.props.renderLoadingExperimental ? this.props.renderLoadingExperimental() : null;\n    }\n    _isStateful() {\n      return isStateful(this.props);\n    }\n    _validateProps(props) {\n      if (this._isStateful()) {\n        return;\n      }\n      var {\n          navigation,\n          screenProps\n        } = props,\n        containerProps = _objectWithoutProperties(props, [\"navigation\", \"screenProps\"]);\n      var keys = Object.keys(containerProps);\n      if (keys.length !== 0) {\n        throw new Error('This navigator has both navigation and container props, so it is ' + \"unclear if it should own its own state. Remove props: \\\"\".concat(keys.join(', '), \"\\\" \") + 'if the navigator should get its state from the navigation prop. If the ' + 'navigator should maintain its own state, do not pass a navigation prop.');\n      }\n    }\n    _onNavigationStateChange(prevNav, nav, action) {\n      if (typeof this.props.onNavigationStateChange === 'undefined' && this._isStateful() && !!process.env.REACT_NAV_LOGGING) {\n        if (console.group) {\n          console.group('Navigation Dispatch: ');\n          console.log('Action: ', action);\n          console.log('New State: ', nav);\n          console.log('Last State: ', prevNav);\n          console.groupEnd();\n        } else {\n          console.log('Navigation Dispatch: ', {\n            action,\n            newState: nav,\n            lastState: prevNav\n          });\n        }\n        return;\n      }\n      if (typeof this.props.onNavigationStateChange === 'function') {\n        this.props.onNavigationStateChange(prevNav, nav, action);\n      }\n    }\n    componentDidUpdate() {\n      if (this._navState === this.state.nav) {\n        this._navState = null;\n      }\n    }\n    componentDidMount() {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        _this2._isMounted = true;\n        if (!_this2._isStateful()) {\n          return;\n        }\n        if (__DEV__ && !_this2.props.detached) {\n          if (_statefulContainerCount > 0) {\n            if (Platform.OS === 'ios') {\n              console.warn(\"You should only render one navigator explicitly in your app, and other navigators should be rendered by including them in that navigator. Full details at: \".concat(docsUrl('common-mistakes.html#explicitly-rendering-more-than-one-navigator')));\n            }\n          }\n        }\n        _statefulContainerCount++;\n        Linking.addEventListener('url', _this2._handleOpenURL);\n        var parsedUrl = null;\n        var userProvidedStartupState = null;\n        if (_this2.props.enableURLHandling !== false) {\n          ({\n            parsedUrl,\n            userProvidedStartupState\n          } = yield _this2.getStartupParams());\n        }\n        var action = _this2._initialAction;\n        var startupState = _this2.state.nav;\n        if (!startupState && !userProvidedStartupState) {\n          !!process.env.REACT_NAV_LOGGING && console.log('Init new Navigation State');\n          startupState = Component.router.getStateForAction(action);\n        }\n        if (userProvidedStartupState) {\n          startupState = userProvidedStartupState;\n          _reactNavigationIsHydratingState = true;\n        }\n        if (parsedUrl) {\n          var {\n            path,\n            params\n          } = parsedUrl;\n          var urlAction = Component.router.getActionForPathAndParams(path, params);\n          if (urlAction) {\n            !!process.env.REACT_NAV_LOGGING && console.log('Applying Navigation Action for Initial URL:', parsedUrl);\n            action = urlAction;\n            startupState = Component.router.getStateForAction(urlAction, startupState);\n          }\n        }\n        var dispatchActions = () => _this2._actionEventSubscribers.forEach(subscriber => subscriber({\n          type: 'action',\n          action,\n          state: _this2.state.nav,\n          lastState: null\n        }));\n        if (startupState === _this2.state.nav) {\n          dispatchActions();\n          return;\n        }\n        _this2.setState({\n          nav: startupState\n        }, () => {\n          _reactNavigationIsHydratingState = false;\n          dispatchActions();\n        });\n      })();\n    }\n    getStartupParams() {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        var {\n          uriPrefix,\n          loadNavigationState\n        } = _this3.props;\n        var url, loadedNavState;\n        try {\n          [url, loadedNavState] = yield Promise.all([Linking.getInitialURL(), loadNavigationState && loadNavigationState()]);\n        } catch (err) {}\n        return {\n          parsedUrl: url && urlToPathAndParams(url, uriPrefix),\n          userProvidedStartupState: loadedNavState\n        };\n      })();\n    }\n    componentDidCatch(e) {\n      if (_reactNavigationIsHydratingState) {\n        _reactNavigationIsHydratingState = false;\n        console.warn('Uncaught exception while starting app from persisted navigation state! Trying to render again with a fresh navigation state...');\n        this.dispatch(NavigationActions.init());\n      } else {\n        throw e;\n      }\n    }\n    componentWillUnmount() {\n      this._isMounted = false;\n      Linking.removeEventListener('url', this._handleOpenURL);\n      this.subs && this.subs.remove();\n      if (this._isStateful()) {\n        _statefulContainerCount--;\n      }\n    }\n    render() {\n      var navigation = this.props.navigation;\n      if (this._isStateful()) {\n        var navState = this.state.nav;\n        if (!navState) {\n          return this._renderLoading();\n        }\n        if (!this._navigation || this._navigation.state !== navState) {\n          this._navigation = getNavigation(Component.router, navState, this.dispatch, this._actionEventSubscribers, this._getScreenProps, () => this._navigation);\n        }\n        navigation = this._navigation;\n      }\n      invariant(navigation, 'failed to get navigation');\n      return React.createElement(NavigationProvider, {\n        value: navigation,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 347\n        }\n      }, React.createElement(Component, _extends({}, this.props, {\n        navigation: navigation,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 348\n        }\n      })));\n    }\n  }\n  NavigationContainer.router = Component.router;\n  NavigationContainer.navigationOptions = null;\n  return NavigationContainer;\n}","map":{"version":3,"names":["React","Linking","Platform","BackHandler","NavigationActions","pathUtils","getNavigation","NavigationProvider","invariant","docsUrl","urlToPathAndParams","isStateful","props","navigation","validateProps","persistenceKey","console","warn","screenProps","persistNavigationState","loadNavigationState","containerProps","_objectWithoutProperties","keys","Object","length","Error","concat","join","undefined","_statefulContainerCount","_TESTING_ONLY_reset_container_count","_reactNavigationIsHydratingState","createNavigationContainer","Component","NavigationContainer","getDerivedStateFromProps","nextProps","constructor","_this","this","subs","_actionEventSubscribers","Set","_handleOpenURL","_ref","url","enableURLHandling","uriPrefix","parsedUrl","path","params","action","router","getActionForPathAndParams","dispatch","_persistNavigationState","_ref2","_asyncToGenerator","nav","err","_x","apply","arguments","_navState","state","lastNavState","reducedState","getStateForAction","navState","dispatchActionEvents","forEach","subscriber","type","lastState","setState","_onNavigationStateChange","_getScreenProps","_initialAction","init","_isStateful","addEventListener","_isMounted","remove","back","_renderLoading","renderLoadingExperimental","_validateProps","prevNav","onNavigationStateChange","process","env","REACT_NAV_LOGGING","group","log","groupEnd","newState","componentDidUpdate","componentDidMount","_this2","__DEV__","detached","OS","userProvidedStartupState","getStartupParams","startupState","urlAction","dispatchActions","_this3","loadedNavState","Promise","all","getInitialURL","componentDidCatch","e","componentWillUnmount","removeEventListener","render","_navigation","createElement","value","__source","fileName","_jsxFileName","lineNumber","_extends","navigationOptions"],"sources":["/Users/zuyax/Developer/rn-starter/node_modules/@react-navigation/native/dist/createAppContainer.js"],"sourcesContent":["import React from 'react';\nimport { Linking, Platform, BackHandler } from 'react-native';\nimport { NavigationActions, pathUtils, getNavigation, NavigationProvider } from '@react-navigation/core';\nimport invariant from './utils/invariant';\nimport docsUrl from './utils/docsUrl';\n\nconst { urlToPathAndParams } = pathUtils;\n\nfunction isStateful(props) {\n  return !props.navigation;\n}\n\nfunction validateProps(props) {\n  if (props.persistenceKey) {\n    console.warn('You passed persistenceKey prop to a navigator. ' + 'The persistenceKey prop was replaced by a more flexible persistence mechanism, ' + 'please see the navigation state persistence docs for more information. ' + 'Passing the persistenceKey prop is a no-op.');\n  }\n  if (isStateful(props)) {\n    return;\n  }\n  /* eslint-disable no-unused-vars */\n  const {\n    navigation,\n    screenProps,\n    persistNavigationState,\n    loadNavigationState,\n    ...containerProps\n  } = props;\n  /* eslint-enable no-unused-vars */\n\n  const keys = Object.keys(containerProps);\n\n  if (keys.length !== 0) {\n    throw new Error('This navigator has both navigation and container props, so it is ' + `unclear if it should own its own state. Remove props: \"${keys.join(', ')}\" ` + 'if the navigator should get its state from the navigation prop. If the ' + 'navigator should maintain its own state, do not pass a navigation prop.');\n  }\n  invariant(persistNavigationState === undefined && loadNavigationState === undefined || typeof persistNavigationState === 'function' && typeof loadNavigationState === 'function', 'both persistNavigationState and loadNavigationState must either be undefined, or be functions');\n}\n\n// Track the number of stateful container instances. Warn if >0 and not using the\n// detached prop to explicitly acknowledge the behavior. We should deprecated implicit\n// stateful navigation containers in a future release and require a provider style pattern\n// instead in order to eliminate confusion entirely.\nlet _statefulContainerCount = 0;\nexport function _TESTING_ONLY_reset_container_count() {\n  _statefulContainerCount = 0;\n}\n\n// We keep a global flag to catch errors during the state persistence hydrating scenario.\n// The innermost navigator who catches the error will dispatch a new init action.\nlet _reactNavigationIsHydratingState = false;\n// Unfortunate to use global state here, but it seems necessesary for the time\n// being. There seems to be some problems with cascading componentDidCatch\n// handlers. Ideally the inner non-stateful navigator catches the error and\n// re-throws it, to be caught by the top-level stateful navigator.\n\n/**\n * Create an HOC that injects the navigation and manages the navigation state\n * in case it's not passed from above.\n * This allows to use e.g. the StackNavigator and TabNavigator as root-level\n * components.\n */\nexport default function createNavigationContainer(Component) {\n  class NavigationContainer extends React.Component {\n    subs = null;\n\n    static router = Component.router;\n    static navigationOptions = null;\n\n    static getDerivedStateFromProps(nextProps) {\n      validateProps(nextProps);\n      return null;\n    }\n\n    _actionEventSubscribers = new Set();\n\n    constructor(props) {\n      super(props);\n\n      validateProps(props);\n\n      this._initialAction = NavigationActions.init();\n\n      if (this._isStateful() && BackHandler && typeof BackHandler.addEventListener === 'function') {\n        this.subs = BackHandler.addEventListener('hardwareBackPress', () => {\n          if (!this._isMounted) {\n            this.subs && this.subs.remove();\n          } else {\n            // dispatch returns true if the action results in a state change,\n            // and false otherwise. This maps well to what BackHandler expects\n            // from a callback -- true if handled, false if not handled\n            return this.dispatch(NavigationActions.back());\n          }\n        });\n      }\n\n      this.state = {\n        nav: this._isStateful() && !props.loadNavigationState ? Component.router.getStateForAction(this._initialAction) : null\n      };\n    }\n\n    _renderLoading() {\n      return this.props.renderLoadingExperimental ? this.props.renderLoadingExperimental() : null;\n    }\n\n    _isStateful() {\n      return isStateful(this.props);\n    }\n\n    _validateProps(props) {\n      if (this._isStateful()) {\n        return;\n      }\n\n      // eslint-disable-next-line no-unused-vars\n      const { navigation, screenProps, ...containerProps } = props;\n\n      const keys = Object.keys(containerProps);\n\n      if (keys.length !== 0) {\n        throw new Error('This navigator has both navigation and container props, so it is ' + `unclear if it should own its own state. Remove props: \"${keys.join(', ')}\" ` + 'if the navigator should get its state from the navigation prop. If the ' + 'navigator should maintain its own state, do not pass a navigation prop.');\n      }\n    }\n\n    _handleOpenURL = ({ url }) => {\n      const { enableURLHandling, uriPrefix } = this.props;\n      if (enableURLHandling === false) {\n        return;\n      }\n      const parsedUrl = urlToPathAndParams(url, uriPrefix);\n      if (parsedUrl) {\n        const { path, params } = parsedUrl;\n        const action = Component.router.getActionForPathAndParams(path, params);\n        if (action) {\n          this.dispatch(action);\n        }\n      }\n    };\n\n    _onNavigationStateChange(prevNav, nav, action) {\n      if (typeof this.props.onNavigationStateChange === 'undefined' && this._isStateful() && !!process.env.REACT_NAV_LOGGING) {\n        if (console.group) {\n          console.group('Navigation Dispatch: ');\n          console.log('Action: ', action);\n          console.log('New State: ', nav);\n          console.log('Last State: ', prevNav);\n          console.groupEnd();\n        } else {\n          console.log('Navigation Dispatch: ', {\n            action,\n            newState: nav,\n            lastState: prevNav\n          });\n        }\n        return;\n      }\n\n      if (typeof this.props.onNavigationStateChange === 'function') {\n        this.props.onNavigationStateChange(prevNav, nav, action);\n      }\n    }\n\n    componentDidUpdate() {\n      // Clear cached _navState every tick\n      if (this._navState === this.state.nav) {\n        this._navState = null;\n      }\n    }\n\n    async componentDidMount() {\n      this._isMounted = true;\n      if (!this._isStateful()) {\n        return;\n      }\n\n      if (__DEV__ && !this.props.detached) {\n        if (_statefulContainerCount > 0) {\n          // Temporarily only show this on iOS due to this issue:\n          // https://github.com/react-navigation/react-navigation/issues/4196#issuecomment-390827829\n          if (Platform.OS === 'ios') {\n            console.warn(`You should only render one navigator explicitly in your app, and other navigators should be rendered by including them in that navigator. Full details at: ${docsUrl('common-mistakes.html#explicitly-rendering-more-than-one-navigator')}`);\n          }\n        }\n      }\n      _statefulContainerCount++;\n      Linking.addEventListener('url', this._handleOpenURL);\n\n      // Pull out anything that can impact state\n      let parsedUrl = null;\n      let userProvidedStartupState = null;\n      if (this.props.enableURLHandling !== false) {\n        ({\n          parsedUrl,\n          userProvidedStartupState\n        } = await this.getStartupParams());\n      }\n\n      // Initialize state. This must be done *after* any async code\n      // so we don't end up with a different value for this.state.nav\n      // due to changes while async function was resolving\n      let action = this._initialAction;\n      let startupState = this.state.nav;\n      if (!startupState && !userProvidedStartupState) {\n        !!process.env.REACT_NAV_LOGGING && console.log('Init new Navigation State');\n        startupState = Component.router.getStateForAction(action);\n      }\n\n      // Pull user-provided persisted state\n      if (userProvidedStartupState) {\n        startupState = userProvidedStartupState;\n        _reactNavigationIsHydratingState = true;\n      }\n\n      // Pull state out of URL\n      if (parsedUrl) {\n        const { path, params } = parsedUrl;\n        const urlAction = Component.router.getActionForPathAndParams(path, params);\n        if (urlAction) {\n          !!process.env.REACT_NAV_LOGGING && console.log('Applying Navigation Action for Initial URL:', parsedUrl);\n          action = urlAction;\n          startupState = Component.router.getStateForAction(urlAction, startupState);\n        }\n      }\n\n      const dispatchActions = () => this._actionEventSubscribers.forEach(subscriber => subscriber({\n        type: 'action',\n        action,\n        state: this.state.nav,\n        lastState: null\n      }));\n\n      if (startupState === this.state.nav) {\n        dispatchActions();\n        return;\n      }\n\n      // eslint-disable-next-line react/no-did-mount-set-state\n      this.setState({ nav: startupState }, () => {\n        _reactNavigationIsHydratingState = false;\n        dispatchActions();\n      });\n    }\n\n    async getStartupParams() {\n      const { uriPrefix, loadNavigationState } = this.props;\n      let url, loadedNavState;\n      try {\n        [url, loadedNavState] = await Promise.all([Linking.getInitialURL(), loadNavigationState && loadNavigationState()]);\n      } catch (err) {\n        // ignore\n      }\n      return {\n        parsedUrl: url && urlToPathAndParams(url, uriPrefix),\n        userProvidedStartupState: loadedNavState\n      };\n    }\n\n    componentDidCatch(e) {\n      if (_reactNavigationIsHydratingState) {\n        _reactNavigationIsHydratingState = false;\n        console.warn('Uncaught exception while starting app from persisted navigation state! Trying to render again with a fresh navigation state...');\n        this.dispatch(NavigationActions.init());\n      } else {\n        throw e;\n      }\n    }\n\n    _persistNavigationState = async nav => {\n      const { persistNavigationState } = this.props;\n      if (persistNavigationState) {\n        try {\n          await persistNavigationState(nav);\n        } catch (err) {\n          console.warn('Uncaught exception while calling persistNavigationState()! You should handle exceptions thrown from persistNavigationState(), ignoring them may result in undefined behavior.');\n        }\n      }\n    };\n\n    componentWillUnmount() {\n      this._isMounted = false;\n      Linking.removeEventListener('url', this._handleOpenURL);\n      this.subs && this.subs.remove();\n\n      if (this._isStateful()) {\n        _statefulContainerCount--;\n      }\n    }\n\n    // Per-tick temporary storage for state.nav\n\n    dispatch = action => {\n      if (this.props.navigation) {\n        return this.props.navigation.dispatch(action);\n      }\n\n      // navState will have the most up-to-date value, because setState sometimes behaves asyncronously\n      this._navState = this._navState || this.state.nav;\n      const lastNavState = this._navState;\n      invariant(lastNavState, 'should be set in constructor if stateful');\n      const reducedState = Component.router.getStateForAction(action, lastNavState);\n      const navState = reducedState === null ? lastNavState : reducedState;\n\n      const dispatchActionEvents = () => {\n        this._actionEventSubscribers.forEach(subscriber => subscriber({\n          type: 'action',\n          action,\n          state: navState,\n          lastState: lastNavState\n        }));\n      };\n\n      if (reducedState === null) {\n        // The router will return null when action has been handled and the state hasn't changed.\n        // dispatch returns true when something has been handled.\n        dispatchActionEvents();\n        return true;\n      }\n\n      if (navState !== lastNavState) {\n        // Cache updates to state.nav during the tick to ensure that subsequent calls will not discard this change\n        this._navState = navState;\n        this.setState({ nav: navState }, () => {\n          this._onNavigationStateChange(lastNavState, navState, action);\n          dispatchActionEvents();\n          this._persistNavigationState(navState);\n        });\n        return true;\n      }\n\n      dispatchActionEvents();\n      return false;\n    };\n\n    _getScreenProps = () => this.props.screenProps;\n\n    render() {\n      let navigation = this.props.navigation;\n      if (this._isStateful()) {\n        const navState = this.state.nav;\n        if (!navState) {\n          return this._renderLoading();\n        }\n        if (!this._navigation || this._navigation.state !== navState) {\n          this._navigation = getNavigation(Component.router, navState, this.dispatch, this._actionEventSubscribers, this._getScreenProps, () => this._navigation);\n        }\n        navigation = this._navigation;\n      }\n      invariant(navigation, 'failed to get navigation');\n      return <NavigationProvider value={navigation}>\n          <Component {...this.props} navigation={navigation} />\n        </NavigationProvider>;\n    }\n  }\n\n  return NavigationContainer;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}