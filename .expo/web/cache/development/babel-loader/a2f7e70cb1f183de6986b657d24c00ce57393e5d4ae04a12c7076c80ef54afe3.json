{"ast":null,"code":"function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nimport * as TaskManager from 'expo-task-manager';\nimport { UnavailabilityError } from '@unimodules/core';\nimport { Platform, NativeModulesProxy } from '@unimodules/core';\nvar {\n  ExpoBackgroundFetch\n} = NativeModulesProxy;\nvar BackgroundFetchResult;\n(function (BackgroundFetchResult) {\n  BackgroundFetchResult[BackgroundFetchResult[\"NoData\"] = 1] = \"NoData\";\n  BackgroundFetchResult[BackgroundFetchResult[\"NewData\"] = 2] = \"NewData\";\n  BackgroundFetchResult[BackgroundFetchResult[\"Failed\"] = 3] = \"Failed\";\n})(BackgroundFetchResult || (BackgroundFetchResult = {}));\nvar BackgroundFetchStatus;\n(function (BackgroundFetchStatus) {\n  BackgroundFetchStatus[BackgroundFetchStatus[\"Denied\"] = 1] = \"Denied\";\n  BackgroundFetchStatus[BackgroundFetchStatus[\"Restricted\"] = 2] = \"Restricted\";\n  BackgroundFetchStatus[BackgroundFetchStatus[\"Available\"] = 3] = \"Available\";\n})(BackgroundFetchStatus || (BackgroundFetchStatus = {}));\nexport function getStatusAsync() {\n  return _getStatusAsync.apply(this, arguments);\n}\nfunction _getStatusAsync() {\n  _getStatusAsync = _asyncToGenerator(function* () {\n    if (Platform.OS !== 'ios') {\n      return BackgroundFetchStatus.Available;\n    }\n    return ExpoBackgroundFetch.getStatusAsync();\n  });\n  return _getStatusAsync.apply(this, arguments);\n}\nexport function setMinimumIntervalAsync(_x) {\n  return _setMinimumIntervalAsync.apply(this, arguments);\n}\nfunction _setMinimumIntervalAsync() {\n  _setMinimumIntervalAsync = _asyncToGenerator(function* (minimumInterval) {\n    if (Platform.OS !== 'ios') {\n      return;\n    }\n    yield ExpoBackgroundFetch.setMinimumIntervalAsync(minimumInterval);\n  });\n  return _setMinimumIntervalAsync.apply(this, arguments);\n}\nexport function registerTaskAsync(_x2) {\n  return _registerTaskAsync.apply(this, arguments);\n}\nfunction _registerTaskAsync() {\n  _registerTaskAsync = _asyncToGenerator(function* (taskName) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!ExpoBackgroundFetch.registerTaskAsync) {\n      throw new UnavailabilityError('BackgroundFetch', 'registerTaskAsync');\n    }\n    if (!TaskManager.isTaskDefined(taskName)) {\n      throw new Error(\"Task '\".concat(taskName, \"' is not defined. You must define a task using TaskManager.defineTask before registering.\"));\n    }\n    yield ExpoBackgroundFetch.registerTaskAsync(taskName, options);\n  });\n  return _registerTaskAsync.apply(this, arguments);\n}\nexport function unregisterTaskAsync(_x3) {\n  return _unregisterTaskAsync.apply(this, arguments);\n}\nfunction _unregisterTaskAsync() {\n  _unregisterTaskAsync = _asyncToGenerator(function* (taskName) {\n    if (!ExpoBackgroundFetch.unregisterTaskAsync) {\n      throw new UnavailabilityError('BackgroundFetch', 'unregisterTaskAsync');\n    }\n    yield ExpoBackgroundFetch.unregisterTaskAsync(taskName);\n  });\n  return _unregisterTaskAsync.apply(this, arguments);\n}\nexport { BackgroundFetchResult as Result, BackgroundFetchStatus as Status };","map":{"version":3,"names":["TaskManager","UnavailabilityError","Platform","NativeModulesProxy","ExpoBackgroundFetch","BackgroundFetchResult","BackgroundFetchStatus","getStatusAsync","_getStatusAsync","apply","arguments","_asyncToGenerator","OS","Available","setMinimumIntervalAsync","_x","_setMinimumIntervalAsync","minimumInterval","registerTaskAsync","_x2","_registerTaskAsync","taskName","options","length","undefined","isTaskDefined","Error","concat","unregisterTaskAsync","_x3","_unregisterTaskAsync","Result","Status"],"sources":["/Users/zuyax/Developer/rn-starter/node_modules/expo-background-fetch/src/BackgroundFetch.ts"],"sourcesContent":["import * as TaskManager from 'expo-task-manager';\nimport { UnavailabilityError } from '@unimodules/core';\nimport { Platform, NativeModulesProxy } from '@unimodules/core';\n\nconst { ExpoBackgroundFetch } = NativeModulesProxy;\n\nenum BackgroundFetchResult {\n  NoData = 1,\n  NewData = 2,\n  Failed = 3,\n}\n\nenum BackgroundFetchStatus {\n  Denied = 1,\n  Restricted = 2,\n  Available = 3,\n}\n\ninterface BackgroundFetchOptions {\n  minimumInterval?: number;\n  stopOnTerminate?: boolean;\n  startOnBoot?: boolean;\n}\n\nexport async function getStatusAsync(): Promise<BackgroundFetchStatus | null> {\n  if (Platform.OS !== 'ios') {\n    return BackgroundFetchStatus.Available;\n  }\n  return ExpoBackgroundFetch.getStatusAsync();\n}\n\nexport async function setMinimumIntervalAsync(minimumInterval: number): Promise<void> {\n  if (Platform.OS !== 'ios') {\n    return;\n  }\n  await ExpoBackgroundFetch.setMinimumIntervalAsync(minimumInterval);\n}\n\nexport async function registerTaskAsync(taskName: string, options: BackgroundFetchOptions = {}): Promise<void> {\n  if (!ExpoBackgroundFetch.registerTaskAsync) {\n    throw new UnavailabilityError('BackgroundFetch', 'registerTaskAsync')\n  }\n  if (!TaskManager.isTaskDefined(taskName)) {\n    throw new Error(\n      `Task '${taskName}' is not defined. You must define a task using TaskManager.defineTask before registering.`\n    );\n  }\n  await ExpoBackgroundFetch.registerTaskAsync(taskName, options);\n}\n\nexport async function unregisterTaskAsync(taskName: string): Promise<void> {\n  if (!ExpoBackgroundFetch.unregisterTaskAsync) {\n    throw new UnavailabilityError('BackgroundFetch', 'unregisterTaskAsync')\n  }\n  await ExpoBackgroundFetch.unregisterTaskAsync(taskName);\n}\n\nexport {\n  BackgroundFetchResult as Result,\n  BackgroundFetchStatus as Status,\n};\n"],"mappings":";;AAAA,OAAO,KAAKA,WAAW,MAAM,mBAAmB;AAChD,SAASC,mBAAmB,QAAQ,kBAAkB;AACtD,SAASC,QAAQ,EAAEC,kBAAkB,QAAQ,kBAAkB;AAE/D,IAAM;EAAEC;AAAmB,CAAE,GAAGD,kBAAkB;AAElD,IAAKE,qBAIJ;AAJD,WAAKA,qBAAqB;EACxBA,qBAAA,CAAAA,qBAAA,0BAAU;EACVA,qBAAA,CAAAA,qBAAA,4BAAW;EACXA,qBAAA,CAAAA,qBAAA,0BAAU;AACZ,CAAC,EAJIA,qBAAqB,KAArBA,qBAAqB;AAM1B,IAAKC,qBAIJ;AAJD,WAAKA,qBAAqB;EACxBA,qBAAA,CAAAA,qBAAA,0BAAU;EACVA,qBAAA,CAAAA,qBAAA,kCAAc;EACdA,qBAAA,CAAAA,qBAAA,gCAAa;AACf,CAAC,EAJIA,qBAAqB,KAArBA,qBAAqB;AAY1B,gBAAsBC,cAAcA,CAAA;EAAA,OAAAC,eAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAKnC,SAAAF,gBAAA;EAAAA,eAAA,GAAAG,iBAAA,CALM,aAA6B;IAClC,IAAIT,QAAQ,CAACU,EAAE,KAAK,KAAK,EAAE;MACzB,OAAON,qBAAqB,CAACO,SAAS;;IAExC,OAAOT,mBAAmB,CAACG,cAAc,EAAE;EAC7C,CAAC;EAAA,OAAAC,eAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAED,gBAAsBI,uBAAuBA,CAAAC,EAAA;EAAA,OAAAC,wBAAA,CAAAP,KAAA,OAAAC,SAAA;AAAA;AAK5C,SAAAM,yBAAA;EAAAA,wBAAA,GAAAL,iBAAA,CALM,WAAuCM,eAAuB;IACnE,IAAIf,QAAQ,CAACU,EAAE,KAAK,KAAK,EAAE;MACzB;;IAEF,MAAMR,mBAAmB,CAACU,uBAAuB,CAACG,eAAe,CAAC;EACpE,CAAC;EAAA,OAAAD,wBAAA,CAAAP,KAAA,OAAAC,SAAA;AAAA;AAED,gBAAsBQ,iBAAiBA,CAAAC,GAAA;EAAA,OAAAC,kBAAA,CAAAX,KAAA,OAAAC,SAAA;AAAA;AAUtC,SAAAU,mBAAA;EAAAA,kBAAA,GAAAT,iBAAA,CAVM,WAAiCU,QAAgB,EAAsC;IAAA,IAApCC,OAAA,GAAAZ,SAAA,CAAAa,MAAA,QAAAb,SAAA,QAAAc,SAAA,GAAAd,SAAA,MAAkC,EAAE;IAC5F,IAAI,CAACN,mBAAmB,CAACc,iBAAiB,EAAE;MAC1C,MAAM,IAAIjB,mBAAmB,CAAC,iBAAiB,EAAE,mBAAmB,CAAC;;IAEvE,IAAI,CAACD,WAAW,CAACyB,aAAa,CAACJ,QAAQ,CAAC,EAAE;MACxC,MAAM,IAAIK,KAAK,UAAAC,MAAA,CACJN,QAAQ,8FAA2F,CAC7G;;IAEH,MAAMjB,mBAAmB,CAACc,iBAAiB,CAACG,QAAQ,EAAEC,OAAO,CAAC;EAChE,CAAC;EAAA,OAAAF,kBAAA,CAAAX,KAAA,OAAAC,SAAA;AAAA;AAED,gBAAsBkB,mBAAmBA,CAAAC,GAAA;EAAA,OAAAC,oBAAA,CAAArB,KAAA,OAAAC,SAAA;AAAA;AAKxC,SAAAoB,qBAAA;EAAAA,oBAAA,GAAAnB,iBAAA,CALM,WAAmCU,QAAgB;IACxD,IAAI,CAACjB,mBAAmB,CAACwB,mBAAmB,EAAE;MAC5C,MAAM,IAAI3B,mBAAmB,CAAC,iBAAiB,EAAE,qBAAqB,CAAC;;IAEzE,MAAMG,mBAAmB,CAACwB,mBAAmB,CAACP,QAAQ,CAAC;EACzD,CAAC;EAAA,OAAAS,oBAAA,CAAArB,KAAA,OAAAC,SAAA;AAAA;AAED,SACEL,qBAAqB,IAAI0B,MAAM,EAC/BzB,qBAAqB,IAAI0B,MAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}