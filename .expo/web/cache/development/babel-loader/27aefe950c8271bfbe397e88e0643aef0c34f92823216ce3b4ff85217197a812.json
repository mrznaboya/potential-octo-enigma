{"ast":null,"code":"function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nimport { EventEmitter, Platform } from '@unimodules/core';\nimport { _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS } from \"../AV\";\nimport ExponentAV from \"../ExponentAV\";\nimport { isAudioEnabled, throwIfAudioIsDisabled } from \"./AudioAvailability\";\nimport { Sound } from \"./Sound\";\nexport var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_DEFAULT = 0;\nexport var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP = 1;\nexport var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4 = 2;\nexport var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_NB = 3;\nexport var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_WB = 4;\nexport var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADIF = 5;\nexport var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADTS = 6;\nexport var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_RTP_AVP = 7;\nexport var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG2TS = 8;\nexport var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_WEBM = 9;\nexport var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_DEFAULT = 0;\nexport var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB = 1;\nexport var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_WB = 2;\nexport var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC = 3;\nexport var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_HE_AAC = 4;\nexport var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC_ELD = 5;\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_LINEARPCM = 'lpcm';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_AC3 = 'ac-3';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_60958AC3 = 'cac3';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLEIMA4 = 'ima4';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC = 'aac ';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4CELP = 'celp';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4HVXC = 'hvxc';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4TWINVQ = 'twvq';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE3 = 'MAC3';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE6 = 'MAC6';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_ULAW = 'ulaw';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_ALAW = 'alaw';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN = 'QDMC';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN2 = 'QDM2';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_QUALCOMM = 'Qclp';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER1 = '.mp1';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER2 = '.mp2';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER3 = '.mp3';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLELOSSLESS = 'alac';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE = 'aach';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_LD = 'aacl';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD = 'aace';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_SBR = 'aacf';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_V2 = 'aacg';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE_V2 = 'aacp';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_SPATIAL = 'aacs';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR = 'samr';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR_WB = 'sawb';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_AUDIBLE = 'AUDB';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_ILBC = 'ilbc';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_DVIINTELIMA = 0x6d730011;\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MICROSOFTGSM = 0x6d730031;\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_AES3 = 'aes3';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_ENHANCEDAC3 = 'ec-3';\nexport var RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN = 0;\nexport var RECORDING_OPTION_IOS_AUDIO_QUALITY_LOW = 0x20;\nexport var RECORDING_OPTION_IOS_AUDIO_QUALITY_MEDIUM = 0x40;\nexport var RECORDING_OPTION_IOS_AUDIO_QUALITY_HIGH = 0x60;\nexport var RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX = 0x7f;\nexport var RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_CONSTANT = 0;\nexport var RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_LONG_TERM_AVERAGE = 1;\nexport var RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE_CONSTRAINED = 2;\nexport var RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE = 3;\nexport var RECORDING_OPTIONS_PRESET_HIGH_QUALITY = {\n  android: {\n    extension: '.m4a',\n    outputFormat: RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4,\n    audioEncoder: RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000\n  },\n  ios: {\n    extension: '.caf',\n    audioQuality: RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n    linearPCMBitDepth: 16,\n    linearPCMIsBigEndian: false,\n    linearPCMIsFloat: false\n  }\n};\nexport var RECORDING_OPTIONS_PRESET_LOW_QUALITY = {\n  android: {\n    extension: '.3gp',\n    outputFormat: RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP,\n    audioEncoder: RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000\n  },\n  ios: {\n    extension: '.caf',\n    audioQuality: RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n    linearPCMBitDepth: 16,\n    linearPCMIsBigEndian: false,\n    linearPCMIsFloat: false\n  }\n};\nvar _recorderExists = false;\nvar eventEmitter = Platform.OS === 'android' ? new EventEmitter(ExponentAV) : null;\nexport class Recording {\n  constructor() {\n    var _this = this;\n    this._subscription = null;\n    this._canRecord = false;\n    this._isDoneRecording = false;\n    this._finalDurationMillis = 0;\n    this._uri = null;\n    this._onRecordingStatusUpdate = null;\n    this._progressUpdateTimeoutVariable = null;\n    this._progressUpdateIntervalMillis = _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;\n    this._options = null;\n    this._cleanupForUnloadedRecorder = function () {\n      var _ref = _asyncToGenerator(function* (finalStatus) {\n        _this._canRecord = false;\n        _this._isDoneRecording = true;\n        _this._finalDurationMillis = finalStatus.durationMillis;\n        _recorderExists = false;\n        if (_this._subscription) {\n          _this._subscription.remove();\n          _this._subscription = null;\n        }\n        _this._disablePolling();\n        return yield _this.getStatusAsync();\n      });\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    this._pollingLoop = _asyncToGenerator(function* () {\n      if (isAudioEnabled() && _this._canRecord && _this._onRecordingStatusUpdate != null) {\n        _this._progressUpdateTimeoutVariable = setTimeout(_this._pollingLoop, _this._progressUpdateIntervalMillis);\n        try {\n          yield _this.getStatusAsync();\n        } catch (error) {\n          _this._disablePolling();\n        }\n      }\n    });\n    this.getStatusAsync = _asyncToGenerator(function* () {\n      if (_this._canRecord) {\n        return _this._performOperationAndHandleStatusAsync(() => ExponentAV.getAudioRecordingStatus());\n      }\n      var status = {\n        canRecord: false,\n        isRecording: false,\n        isDoneRecording: _this._isDoneRecording,\n        durationMillis: _this._finalDurationMillis\n      };\n      _this._callOnRecordingStatusUpdateForNewStatus(status);\n      return status;\n    });\n  }\n  _disablePolling() {\n    if (this._progressUpdateTimeoutVariable != null) {\n      clearTimeout(this._progressUpdateTimeoutVariable);\n      this._progressUpdateTimeoutVariable = null;\n    }\n  }\n  _enablePollingIfNecessaryAndPossible() {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._disablePolling();\n      this._pollingLoop();\n    }\n  }\n  _callOnRecordingStatusUpdateForNewStatus(status) {\n    if (this._onRecordingStatusUpdate != null) {\n      this._onRecordingStatusUpdate(status);\n    }\n  }\n  _performOperationAndHandleStatusAsync(operation) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      throwIfAudioIsDisabled();\n      if (_this2._canRecord) {\n        var status = yield operation();\n        _this2._callOnRecordingStatusUpdateForNewStatus(status);\n        return status;\n      } else {\n        throw new Error('Cannot complete operation because this recorder is not ready to record.');\n      }\n    })();\n  }\n  setOnRecordingStatusUpdate(onRecordingStatusUpdate) {\n    this._onRecordingStatusUpdate = onRecordingStatusUpdate;\n    if (onRecordingStatusUpdate == null) {\n      this._disablePolling();\n    } else {\n      this._enablePollingIfNecessaryAndPossible();\n    }\n    this.getStatusAsync();\n  }\n  setProgressUpdateInterval(progressUpdateIntervalMillis) {\n    this._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n    this.getStatusAsync();\n  }\n  prepareToRecordAsync() {\n    var _arguments = arguments,\n      _this3 = this;\n    return _asyncToGenerator(function* () {\n      var options = _arguments.length > 0 && _arguments[0] !== undefined ? _arguments[0] : RECORDING_OPTIONS_PRESET_LOW_QUALITY;\n      throwIfAudioIsDisabled();\n      if (_recorderExists) {\n        throw new Error('Only one Recording object can be prepared at a given time.');\n      }\n      if (_this3._isDoneRecording) {\n        throw new Error('This Recording object is done recording; you must make a new one.');\n      }\n      if (!options || !options.android || !options.ios) {\n        throw new Error('You must provide recording options for android and ios in order to prepare to record.');\n      }\n      var extensionRegex = /^\\.\\w+$/;\n      if (!options.android.extension || !options.ios.extension || !extensionRegex.test(options.android.extension) || !extensionRegex.test(options.ios.extension)) {\n        throw new Error(\"Your file extensions must match \".concat(extensionRegex.toString(), \".\"));\n      }\n      if (!_this3._canRecord) {\n        if (eventEmitter) {\n          _this3._subscription = eventEmitter.addListener('Expo.Recording.recorderUnloaded', _this3._cleanupForUnloadedRecorder);\n        }\n        var {\n          uri,\n          status\n        } = yield ExponentAV.prepareAudioRecorder(options);\n        _recorderExists = true;\n        _this3._uri = uri;\n        _this3._options = options;\n        _this3._canRecord = true;\n        var currentStatus = _objectSpread({}, status, {\n          canRecord: true\n        });\n        _this3._callOnRecordingStatusUpdateForNewStatus(currentStatus);\n        _this3._enablePollingIfNecessaryAndPossible();\n        return currentStatus;\n      } else {\n        throw new Error('This Recording object is already prepared to record.');\n      }\n    })();\n  }\n  startAsync() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      return _this4._performOperationAndHandleStatusAsync(() => ExponentAV.startAudioRecording());\n    })();\n  }\n  pauseAsync() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      return _this5._performOperationAndHandleStatusAsync(() => ExponentAV.pauseAudioRecording());\n    })();\n  }\n  stopAndUnloadAsync() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this6._canRecord) {\n        if (_this6._isDoneRecording) {\n          throw new Error('Cannot unload a Recording that has already been unloaded.');\n        } else {\n          throw new Error('Cannot unload a Recording that has not been prepared.');\n        }\n      }\n      var finalStatus = yield ExponentAV.stopAudioRecording();\n      yield ExponentAV.unloadAudioRecorder();\n      return _this6._cleanupForUnloadedRecorder(finalStatus);\n    })();\n  }\n  getURI() {\n    return this._uri;\n  }\n  createNewLoadedSound() {\n    var _arguments2 = arguments,\n      _this7 = this;\n    return _asyncToGenerator(function* () {\n      var initialStatus = _arguments2.length > 0 && _arguments2[0] !== undefined ? _arguments2[0] : {};\n      var onPlaybackStatusUpdate = _arguments2.length > 1 && _arguments2[1] !== undefined ? _arguments2[1] : null;\n      console.warn(\"createNewLoadedSound is deprecated in favor of createNewLoadedSoundAsync, which has the same API aside from the method name\");\n      return _this7.createNewLoadedSoundAsync(initialStatus, onPlaybackStatusUpdate);\n    })();\n  }\n  createNewLoadedSoundAsync() {\n    var _arguments3 = arguments,\n      _this8 = this;\n    return _asyncToGenerator(function* () {\n      var initialStatus = _arguments3.length > 0 && _arguments3[0] !== undefined ? _arguments3[0] : {};\n      var onPlaybackStatusUpdate = _arguments3.length > 1 && _arguments3[1] !== undefined ? _arguments3[1] : null;\n      if (_this8._uri == null || !_this8._isDoneRecording) {\n        throw new Error('Cannot create sound when the Recording has not finished!');\n      }\n      return Sound.createAsync({\n        uri: _this8._uri\n      }, initialStatus, onPlaybackStatusUpdate, false);\n    })();\n  }\n}","map":{"version":3,"names":["EventEmitter","Platform","_DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS","ExponentAV","isAudioEnabled","throwIfAudioIsDisabled","Sound","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_DEFAULT","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_NB","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_WB","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADIF","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADTS","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_RTP_AVP","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG2TS","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_WEBM","RECORDING_OPTION_ANDROID_AUDIO_ENCODER_DEFAULT","RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB","RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_WB","RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC","RECORDING_OPTION_ANDROID_AUDIO_ENCODER_HE_AAC","RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC_ELD","RECORDING_OPTION_IOS_OUTPUT_FORMAT_LINEARPCM","RECORDING_OPTION_IOS_OUTPUT_FORMAT_AC3","RECORDING_OPTION_IOS_OUTPUT_FORMAT_60958AC3","RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLEIMA4","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4CELP","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4HVXC","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4TWINVQ","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE3","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE6","RECORDING_OPTION_IOS_OUTPUT_FORMAT_ULAW","RECORDING_OPTION_IOS_OUTPUT_FORMAT_ALAW","RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN","RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN2","RECORDING_OPTION_IOS_OUTPUT_FORMAT_QUALCOMM","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER1","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER2","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER3","RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLELOSSLESS","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_LD","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_SBR","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_V2","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE_V2","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_SPATIAL","RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR","RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR_WB","RECORDING_OPTION_IOS_OUTPUT_FORMAT_AUDIBLE","RECORDING_OPTION_IOS_OUTPUT_FORMAT_ILBC","RECORDING_OPTION_IOS_OUTPUT_FORMAT_DVIINTELIMA","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MICROSOFTGSM","RECORDING_OPTION_IOS_OUTPUT_FORMAT_AES3","RECORDING_OPTION_IOS_OUTPUT_FORMAT_ENHANCEDAC3","RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN","RECORDING_OPTION_IOS_AUDIO_QUALITY_LOW","RECORDING_OPTION_IOS_AUDIO_QUALITY_MEDIUM","RECORDING_OPTION_IOS_AUDIO_QUALITY_HIGH","RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX","RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_CONSTANT","RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_LONG_TERM_AVERAGE","RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE_CONSTRAINED","RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE","RECORDING_OPTIONS_PRESET_HIGH_QUALITY","android","extension","outputFormat","audioEncoder","sampleRate","numberOfChannels","bitRate","ios","audioQuality","linearPCMBitDepth","linearPCMIsBigEndian","linearPCMIsFloat","RECORDING_OPTIONS_PRESET_LOW_QUALITY","_recorderExists","eventEmitter","OS","Recording","constructor","_this","_subscription","_canRecord","_isDoneRecording","_finalDurationMillis","_uri","_onRecordingStatusUpdate","_progressUpdateTimeoutVariable","_progressUpdateIntervalMillis","_options","_cleanupForUnloadedRecorder","_ref","_asyncToGenerator","finalStatus","durationMillis","remove","_disablePolling","getStatusAsync","_x","apply","arguments","_pollingLoop","setTimeout","error","_performOperationAndHandleStatusAsync","getAudioRecordingStatus","status","canRecord","isRecording","isDoneRecording","_callOnRecordingStatusUpdateForNewStatus","clearTimeout","_enablePollingIfNecessaryAndPossible","operation","_this2","Error","setOnRecordingStatusUpdate","onRecordingStatusUpdate","setProgressUpdateInterval","progressUpdateIntervalMillis","prepareToRecordAsync","_arguments","_this3","options","length","undefined","extensionRegex","test","concat","toString","addListener","uri","prepareAudioRecorder","currentStatus","_objectSpread","startAsync","_this4","startAudioRecording","pauseAsync","_this5","pauseAudioRecording","stopAndUnloadAsync","_this6","stopAudioRecording","unloadAudioRecorder","getURI","createNewLoadedSound","_arguments2","_this7","initialStatus","onPlaybackStatusUpdate","console","warn","createNewLoadedSoundAsync","_arguments3","_this8","createAsync"],"sources":["/Users/zuyax/Developer/rn-starter/node_modules/expo-av/src/Audio/Recording.ts"],"sourcesContent":["import { NativeModulesProxy, EventEmitter, Subscription, Platform } from '@unimodules/core';\n\nimport {\n  _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  PlaybackStatus,\n  PlaybackStatusToSet,\n} from '../AV';\n\nimport ExponentAV from '../ExponentAV';\nimport { isAudioEnabled, throwIfAudioIsDisabled } from './AudioAvailability';\n\nimport { Sound } from './Sound';\n\nexport type RecordingOptions = {\n  android: {\n    extension: string;\n    outputFormat: number;\n    audioEncoder: number;\n    sampleRate?: number;\n    numberOfChannels?: number;\n    bitRate?: number;\n    maxFileSize?: number;\n  };\n  ios: {\n    extension: string;\n    outputFormat?: string | number;\n    audioQuality: number;\n    sampleRate: number;\n    numberOfChannels: number;\n    bitRate: number;\n    bitRateStrategy?: number;\n    bitDepthHint?: number;\n    linearPCMBitDepth?: number;\n    linearPCMIsBigEndian?: boolean;\n    linearPCMIsFloat?: boolean;\n  };\n};\n\n// TODO: consider changing these to enums\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_DEFAULT = 0;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP = 1;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4 = 2;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_NB = 3;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_WB = 4;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADIF = 5;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADTS = 6;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_RTP_AVP = 7;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG2TS = 8;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_WEBM = 9;\n\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_DEFAULT = 0;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB = 1;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_WB = 2;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC = 3;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_HE_AAC = 4;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC_ELD = 5;\n\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_LINEARPCM = 'lpcm';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AC3 = 'ac-3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_60958AC3 = 'cac3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLEIMA4 = 'ima4';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC = 'aac ';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4CELP = 'celp';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4HVXC = 'hvxc';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4TWINVQ = 'twvq';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE3 = 'MAC3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE6 = 'MAC6';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ULAW = 'ulaw';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ALAW = 'alaw';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN = 'QDMC';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN2 = 'QDM2';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_QUALCOMM = 'Qclp';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER1 = '.mp1';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER2 = '.mp2';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER3 = '.mp3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLELOSSLESS = 'alac';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE = 'aach';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_LD = 'aacl';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD = 'aace';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_SBR = 'aacf';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_V2 = 'aacg';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE_V2 = 'aacp';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_SPATIAL = 'aacs';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR = 'samr';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR_WB = 'sawb';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AUDIBLE = 'AUDB';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ILBC = 'ilbc';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_DVIINTELIMA = 0x6d730011;\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MICROSOFTGSM = 0x6d730031;\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AES3 = 'aes3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ENHANCEDAC3 = 'ec-3';\n\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN = 0;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_LOW = 0x20;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_MEDIUM = 0x40;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_HIGH = 0x60;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX = 0x7f;\n\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_CONSTANT = 0;\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_LONG_TERM_AVERAGE = 1;\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE_CONSTRAINED = 2;\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE = 3;\n\n// TODO : maybe make presets for music and speech, or lossy / lossless.\n\nexport const RECORDING_OPTIONS_PRESET_HIGH_QUALITY: RecordingOptions = {\n  android: {\n    extension: '.m4a',\n    outputFormat: RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4,\n    audioEncoder: RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n  },\n  ios: {\n    extension: '.caf',\n    audioQuality: RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n    linearPCMBitDepth: 16,\n    linearPCMIsBigEndian: false,\n    linearPCMIsFloat: false,\n  },\n};\n\nexport const RECORDING_OPTIONS_PRESET_LOW_QUALITY: RecordingOptions = {\n  android: {\n    extension: '.3gp',\n    outputFormat: RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP,\n    audioEncoder: RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n  },\n  ios: {\n    extension: '.caf',\n    audioQuality: RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n    linearPCMBitDepth: 16,\n    linearPCMIsBigEndian: false,\n    linearPCMIsFloat: false,\n  },\n};\n\n// TODO: For consistency with PlaybackStatus, should we include progressUpdateIntervalMillis here as\n// well?\nexport type RecordingStatus = {\n  canRecord: boolean;\n  isRecording: boolean;\n  isDoneRecording: boolean;\n  durationMillis: number;\n};\n\nlet _recorderExists: boolean = false;\nconst eventEmitter = Platform.OS === 'android' ? new EventEmitter(ExponentAV) : null;\n\nexport class Recording {\n  _subscription: Subscription | null = null;\n  _canRecord: boolean = false;\n  _isDoneRecording: boolean = false;\n  _finalDurationMillis: number = 0;\n  _uri: string | null = null;\n  _onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null = null;\n  _progressUpdateTimeoutVariable: number | null = null;\n  _progressUpdateIntervalMillis: number = _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;\n  _options: RecordingOptions | null = null;\n\n  // Internal methods\n\n  _cleanupForUnloadedRecorder = async (finalStatus: RecordingStatus) => {\n    this._canRecord = false;\n    this._isDoneRecording = true;\n    // $FlowFixMe(greg): durationMillis is not always defined\n    this._finalDurationMillis = finalStatus.durationMillis;\n    _recorderExists = false;\n    if (this._subscription) {\n      this._subscription.remove();\n      this._subscription = null;\n    }\n    this._disablePolling();\n    return await this.getStatusAsync(); // Automatically calls onRecordingStatusUpdate for the final state.\n  };\n\n  _pollingLoop = async () => {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._progressUpdateTimeoutVariable = <any>setTimeout(\n        this._pollingLoop,\n        this._progressUpdateIntervalMillis\n      );\n      try {\n        await this.getStatusAsync();\n      } catch (error) {\n        this._disablePolling();\n      }\n    }\n  };\n\n  _disablePolling() {\n    if (this._progressUpdateTimeoutVariable != null) {\n      clearTimeout(this._progressUpdateTimeoutVariable);\n      this._progressUpdateTimeoutVariable = null;\n    }\n  }\n\n  _enablePollingIfNecessaryAndPossible() {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._disablePolling();\n      this._pollingLoop();\n    }\n  }\n\n  _callOnRecordingStatusUpdateForNewStatus(status: RecordingStatus) {\n    if (this._onRecordingStatusUpdate != null) {\n      this._onRecordingStatusUpdate(status);\n    }\n  }\n\n  async _performOperationAndHandleStatusAsync(\n    operation: () => Promise<RecordingStatus>\n  ): Promise<RecordingStatus> {\n    throwIfAudioIsDisabled();\n    if (this._canRecord) {\n      const status = await operation();\n      this._callOnRecordingStatusUpdateForNewStatus(status);\n      return status;\n    } else {\n      throw new Error('Cannot complete operation because this recorder is not ready to record.');\n    }\n  }\n\n  // Note that all calls automatically call onRecordingStatusUpdate as a side effect.\n\n  // Get status API\n\n  getStatusAsync = async (): Promise<RecordingStatus> => {\n    // Automatically calls onRecordingStatusUpdate.\n    if (this._canRecord) {\n      return this._performOperationAndHandleStatusAsync(() => ExponentAV.getAudioRecordingStatus());\n    }\n    const status = {\n      canRecord: false,\n      isRecording: false,\n      isDoneRecording: this._isDoneRecording,\n      durationMillis: this._finalDurationMillis,\n    };\n    this._callOnRecordingStatusUpdateForNewStatus(status);\n    return status;\n  };\n\n  setOnRecordingStatusUpdate(onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null) {\n    this._onRecordingStatusUpdate = onRecordingStatusUpdate;\n    if (onRecordingStatusUpdate == null) {\n      this._disablePolling();\n    } else {\n      this._enablePollingIfNecessaryAndPossible();\n    }\n    this.getStatusAsync();\n  }\n\n  setProgressUpdateInterval(progressUpdateIntervalMillis: number) {\n    this._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n    this.getStatusAsync();\n  }\n\n  // Record API\n\n  async prepareToRecordAsync(\n    options: RecordingOptions = RECORDING_OPTIONS_PRESET_LOW_QUALITY\n  ): Promise<RecordingStatus> {\n    throwIfAudioIsDisabled();\n\n    if (_recorderExists) {\n      throw new Error('Only one Recording object can be prepared at a given time.');\n    }\n\n    if (this._isDoneRecording) {\n      throw new Error('This Recording object is done recording; you must make a new one.');\n    }\n\n    if (!options || !options.android || !options.ios) {\n      throw new Error(\n        'You must provide recording options for android and ios in order to prepare to record.'\n      );\n    }\n\n    const extensionRegex = /^\\.\\w+$/;\n    if (\n      !options.android.extension ||\n      !options.ios.extension ||\n      !extensionRegex.test(options.android.extension) ||\n      !extensionRegex.test(options.ios.extension)\n    ) {\n      throw new Error(`Your file extensions must match ${extensionRegex.toString()}.`);\n    }\n\n    if (!this._canRecord) {\n      if (eventEmitter) {\n        this._subscription = eventEmitter.addListener(\n          'Expo.Recording.recorderUnloaded',\n          this._cleanupForUnloadedRecorder\n        );\n      }\n\n      const {\n        uri,\n        status,\n      }: {\n        uri: string;\n        // status is of type RecordingStatus, but without the canRecord field populated\n        status: Pick<RecordingStatus, Exclude<keyof RecordingStatus, 'canRecord'>>;\n      } = await ExponentAV.prepareAudioRecorder(options);\n\n      _recorderExists = true;\n      this._uri = uri;\n      this._options = options;\n      this._canRecord = true;\n\n      const currentStatus = { ...status, canRecord: true };\n      this._callOnRecordingStatusUpdateForNewStatus(currentStatus);\n      this._enablePollingIfNecessaryAndPossible();\n      return currentStatus;\n    } else {\n      throw new Error('This Recording object is already prepared to record.');\n    }\n  }\n\n  async startAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() => ExponentAV.startAudioRecording());\n  }\n\n  async pauseAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() => ExponentAV.pauseAudioRecording());\n  }\n\n  async stopAndUnloadAsync(): Promise<RecordingStatus> {\n    if (!this._canRecord) {\n      if (this._isDoneRecording) {\n        throw new Error('Cannot unload a Recording that has already been unloaded.');\n      } else {\n        throw new Error('Cannot unload a Recording that has not been prepared.');\n      }\n    }\n    // We perform a separate native API call so that the state of the Recording can be updated with\n    // the final duration of the recording. (We cast stopStatus as Object to appease Flow)\n    const finalStatus = await ExponentAV.stopAudioRecording();\n    await ExponentAV.unloadAudioRecorder();\n    return this._cleanupForUnloadedRecorder(finalStatus);\n  }\n\n  // Read API\n\n  getURI(): string | null {\n    return this._uri;\n  }\n\n  async createNewLoadedSound(\n    initialStatus: PlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: PlaybackStatus) => void) | null = null\n  ): Promise<{ sound: Sound; status: PlaybackStatus }> {\n    console.warn(\n      `createNewLoadedSound is deprecated in favor of createNewLoadedSoundAsync, which has the same API aside from the method name`\n    );\n    return this.createNewLoadedSoundAsync(initialStatus, onPlaybackStatusUpdate);\n  }\n\n  async createNewLoadedSoundAsync(\n    initialStatus: PlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: PlaybackStatus) => void) | null = null\n  ): Promise<{ sound: Sound; status: PlaybackStatus }> {\n    if (this._uri == null || !this._isDoneRecording) {\n      throw new Error('Cannot create sound when the Recording has not finished!');\n    }\n    return Sound.createAsync(\n      // $FlowFixMe: Flow can't distinguish between this literal and Asset\n      { uri: this._uri },\n      initialStatus,\n      onPlaybackStatusUpdate,\n      false\n    );\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}