{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _objectSpread from \"@babel/runtime/helpers/objectSpread\";\nimport * as NavigationActions from \"../NavigationActions\";\nimport * as StackActions from \"./StackActions\";\nimport createConfigGetter from \"./createConfigGetter\";\nimport getScreenForRouteName from \"./getScreenForRouteName\";\nimport StateUtils from \"../StateUtils\";\nimport validateRouteConfigMap from \"./validateRouteConfigMap\";\nimport invariant from \"../utils/invariant\";\nimport { generateKey } from \"./KeyGenerator\";\nimport { createPathParser } from \"./pathUtils\";\nfunction behavesLikePushAction(action) {\n  return action.type === NavigationActions.NAVIGATE || action.type === StackActions.PUSH;\n}\nvar defaultActionCreators = function defaultActionCreators() {\n  return {};\n};\nfunction isResetToRootStack(action) {\n  return action.type === StackActions.RESET && action.key === null;\n}\nexport default (function (routeConfigs) {\n  var stackConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  validateRouteConfigMap(routeConfigs);\n  var childRouters = {};\n  var routeNames = Object.keys(routeConfigs);\n  routeNames.forEach(function (routeName) {\n    var routeConfig = routeConfigs[routeName];\n    var screen = routeConfig && routeConfig.screen ? routeConfig.screen : routeConfig;\n    if (screen && screen.router) {\n      childRouters[routeName] = screen.router;\n    } else {\n      childRouters[routeName] = null;\n    }\n  });\n  var initialRouteParams = stackConfig.initialRouteParams;\n  var getCustomActionCreators = stackConfig.getCustomActionCreators || defaultActionCreators;\n  var initialRouteName = stackConfig.initialRouteName || routeNames[0];\n  var initialChildRouter = childRouters[initialRouteName];\n  function getInitialState(action) {\n    var route = {};\n    var childRouter = childRouters[action.routeName];\n    if (behavesLikePushAction(action) && childRouter !== undefined) {\n      var childState = {};\n      if (childRouter !== null) {\n        var childAction = action.action || NavigationActions.init({\n          params: action.params\n        });\n        childState = childRouter.getStateForAction(childAction);\n      }\n      return {\n        key: 'StackRouterRoot',\n        isTransitioning: false,\n        index: 0,\n        routes: [_objectSpread({\n          params: action.params\n        }, childState, {\n          key: action.key || generateKey(),\n          routeName: action.routeName\n        })]\n      };\n    }\n    if (initialChildRouter) {\n      route = initialChildRouter.getStateForAction(NavigationActions.navigate({\n        routeName: initialRouteName,\n        params: initialRouteParams\n      }));\n    }\n    var params = (routeConfigs[initialRouteName].params || route.params || action.params || initialRouteParams) && _objectSpread({}, routeConfigs[initialRouteName].params || {}, route.params || {}, action.params || {}, initialRouteParams || {});\n    var initialRouteKey = stackConfig.initialRouteKey;\n    route = _objectSpread({}, route, params ? {\n      params: params\n    } : {}, {\n      routeName: initialRouteName,\n      key: action.key || initialRouteKey || generateKey()\n    });\n    return {\n      key: 'StackRouterRoot',\n      isTransitioning: false,\n      index: 0,\n      routes: [route]\n    };\n  }\n  function getParamsForRouteAndAction(routeName, action) {\n    var routeConfig = routeConfigs[routeName];\n    if (routeConfig && routeConfig.params) {\n      return _objectSpread({}, routeConfig.params, action.params);\n    } else {\n      return action.params;\n    }\n  }\n  var _createPathParser = createPathParser(childRouters, routeConfigs, stackConfig),\n    getPathAndParamsForRoute = _createPathParser.getPathAndParamsForRoute,\n    _getActionForPathAndParams = _createPathParser.getActionForPathAndParams;\n  return {\n    childRouters: childRouters,\n    getComponentForState: function getComponentForState(state) {\n      var activeChildRoute = state.routes[state.index];\n      var routeName = activeChildRoute.routeName;\n      if (childRouters[routeName]) {\n        return childRouters[routeName].getComponentForState(activeChildRoute);\n      }\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n    getComponentForRouteName: function getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n    getActionCreators: function getActionCreators(route, navStateKey) {\n      return _objectSpread({}, getCustomActionCreators(route, navStateKey), {\n        pop: function pop(n, params) {\n          return StackActions.pop(_objectSpread({\n            n: n\n          }, params));\n        },\n        popToTop: function popToTop(params) {\n          return StackActions.popToTop(params);\n        },\n        push: function push(routeName, params, action) {\n          return StackActions.push({\n            routeName: routeName,\n            params: params,\n            action: action\n          });\n        },\n        replace: function replace(replaceWith, params, action, newKey) {\n          if (typeof replaceWith === 'string') {\n            return StackActions.replace({\n              routeName: replaceWith,\n              params: params,\n              action: action,\n              key: route.key,\n              newKey: newKey\n            });\n          }\n          invariant(typeof replaceWith === 'object', 'Must replaceWith an object or a string');\n          invariant(params == null, 'Params must not be provided to .replace() when specifying an object');\n          invariant(action == null, 'Child action must not be provided to .replace() when specifying an object');\n          invariant(newKey == null, 'Child action must not be provided to .replace() when specifying an object');\n          return StackActions.replace(replaceWith);\n        },\n        reset: function reset(actions, index) {\n          return StackActions.reset({\n            actions: actions,\n            index: index == null ? actions.length - 1 : index,\n            key: navStateKey\n          });\n        },\n        dismiss: function dismiss() {\n          return NavigationActions.back({\n            key: navStateKey\n          });\n        }\n      });\n    },\n    getStateForAction: function getStateForAction(action, state) {\n      if (!state) {\n        return getInitialState(action);\n      }\n      var activeChildRoute = state.routes[state.index];\n      if (!isResetToRootStack(action) && action.type !== NavigationActions.NAVIGATE) {\n        var activeChildRouter = childRouters[activeChildRoute.routeName];\n        if (activeChildRouter) {\n          var route = activeChildRouter.getStateForAction(action, activeChildRoute);\n          if (route !== null && route !== activeChildRoute) {\n            return StateUtils.replaceAt(state, activeChildRoute.key, route, action.type === NavigationActions.SET_PARAMS);\n          }\n        }\n      } else if (action.type === NavigationActions.NAVIGATE) {\n        for (var _iterator = state.routes.slice().reverse(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"]();;) {\n          var _ref;\n          if (_isArray) {\n            if (_i >= _iterator.length) break;\n            _ref = _iterator[_i++];\n          } else {\n            _i = _iterator.next();\n            if (_i.done) break;\n            _ref = _i.value;\n          }\n          var _childRoute = _ref;\n          var childRouter = childRouters[_childRoute.routeName];\n          var childAction = action.routeName === _childRoute.routeName && action.action ? action.action : action;\n          if (childRouter) {\n            var nextRouteState = childRouter.getStateForAction(childAction, _childRoute);\n            if (nextRouteState === null || nextRouteState !== _childRoute) {\n              var newState = StateUtils.replaceAndPrune(state, nextRouteState ? nextRouteState.key : _childRoute.key, nextRouteState ? nextRouteState : _childRoute);\n              return _objectSpread({}, newState, {\n                isTransitioning: state.index !== newState.index ? action.immediate !== true : state.isTransitioning\n              });\n            }\n          }\n        }\n      }\n      if (behavesLikePushAction(action) && childRouters[action.routeName] !== undefined) {\n        var _childRouter = childRouters[action.routeName];\n        var _route;\n        invariant(action.type !== StackActions.PUSH || action.key == null, 'StackRouter does not support key on the push action');\n        var lastRouteIndex = state.routes.findIndex(function (r) {\n          if (action.key) {\n            return r.key === action.key;\n          } else {\n            return r.routeName === action.routeName;\n          }\n        });\n        if (action.type !== StackActions.PUSH && lastRouteIndex !== -1) {\n          if (state.index === lastRouteIndex && !action.params) {\n            return null;\n          }\n          var routes = state.routes.slice(0, lastRouteIndex + 1);\n          if (action.params) {\n            var _route2 = state.routes[lastRouteIndex];\n            routes[lastRouteIndex] = _objectSpread({}, _route2, {\n              params: _objectSpread({}, _route2.params, action.params)\n            });\n          }\n          return _objectSpread({}, state, {\n            isTransitioning: state.index !== lastRouteIndex ? action.immediate !== true : state.isTransitioning,\n            index: lastRouteIndex,\n            routes: routes\n          });\n        }\n        if (_childRouter) {\n          var _childAction = action.action || NavigationActions.init({\n            params: getParamsForRouteAndAction(action.routeName, action)\n          });\n          _route = _objectSpread({\n            params: getParamsForRouteAndAction(action.routeName, action)\n          }, _childRouter.getStateForAction(_childAction), {\n            routeName: action.routeName,\n            key: action.key || generateKey()\n          });\n        } else {\n          _route = {\n            params: getParamsForRouteAndAction(action.routeName, action),\n            routeName: action.routeName,\n            key: action.key || generateKey()\n          };\n        }\n        return _objectSpread({}, StateUtils.push(state, _route), {\n          isTransitioning: action.immediate !== true\n        });\n      } else if (action.type === StackActions.PUSH && childRouters[action.routeName] === undefined) {\n        return state;\n      }\n      if (behavesLikePushAction(action)) {\n        var childRouterNames = Object.keys(childRouters);\n        for (var i = 0; i < childRouterNames.length; i++) {\n          var childRouterName = childRouterNames[i];\n          var _childRouter2 = childRouters[childRouterName];\n          if (_childRouter2) {\n            var initChildRoute = _childRouter2.getStateForAction(NavigationActions.init());\n            var navigatedChildRoute = _childRouter2.getStateForAction(action, initChildRoute);\n            var routeToPush = null;\n            if (navigatedChildRoute === null) {\n              routeToPush = initChildRoute;\n            } else if (navigatedChildRoute !== initChildRoute) {\n              routeToPush = navigatedChildRoute;\n            }\n            if (routeToPush) {\n              var _route3 = _objectSpread({}, routeToPush, {\n                routeName: childRouterName,\n                key: action.key || generateKey()\n              });\n              return _objectSpread({}, StateUtils.push(state, _route3), {\n                isTransitioning: action.immediate !== true\n              });\n            }\n          }\n        }\n      }\n      if (action.type === StackActions.POP_TO_TOP) {\n        if (action.key && state.key !== action.key) {\n          return state;\n        }\n        if (state.index > 0) {\n          return _objectSpread({}, state, {\n            isTransitioning: action.immediate !== true,\n            index: 0,\n            routes: [state.routes[0]]\n          });\n        }\n        return state;\n      }\n      if (action.type === StackActions.REPLACE) {\n        var routeIndex;\n        if (action.key === undefined && state.routes.length) {\n          routeIndex = state.routes.length - 1;\n        } else {\n          routeIndex = state.routes.findIndex(function (r) {\n            return r.key === action.key;\n          });\n        }\n        if (routeIndex !== -1) {\n          var _childRouter3 = childRouters[action.routeName];\n          var childState = {};\n          if (_childRouter3) {\n            var _childAction2 = action.action || NavigationActions.init({\n              params: getParamsForRouteAndAction(action.routeName, action)\n            });\n            childState = _childRouter3.getStateForAction(_childAction2);\n          }\n          var _routes = _toConsumableArray(state.routes);\n          _routes[routeIndex] = _objectSpread({\n            params: getParamsForRouteAndAction(action.routeName, action)\n          }, childState, {\n            routeName: action.routeName,\n            key: action.newKey || generateKey()\n          });\n          return _objectSpread({}, state, {\n            routes: _routes\n          });\n        }\n      }\n      if (action.type === StackActions.COMPLETE_TRANSITION && (action.key == null || action.key === state.key) && action.toChildKey === state.routes[state.index].key && state.isTransitioning) {\n        return _objectSpread({}, state, {\n          isTransitioning: false\n        });\n      }\n      if (action.type === NavigationActions.SET_PARAMS) {\n        var key = action.key;\n        var lastRoute = state.routes.find(function (route) {\n          return route.key === key;\n        });\n        if (lastRoute) {\n          var params = _objectSpread({}, lastRoute.params, action.params);\n          var _routes2 = _toConsumableArray(state.routes);\n          _routes2[state.routes.indexOf(lastRoute)] = _objectSpread({}, lastRoute, {\n            params: params\n          });\n          return _objectSpread({}, state, {\n            routes: _routes2\n          });\n        }\n      }\n      if (action.type === StackActions.RESET) {\n        if (action.key != null && action.key != state.key) {\n          return state;\n        }\n        var newStackActions = action.actions;\n        return _objectSpread({}, state, {\n          routes: newStackActions.map(function (newStackAction) {\n            var router = childRouters[newStackAction.routeName];\n            var childState = {};\n            if (router) {\n              var _childAction3 = newStackAction.action || NavigationActions.init({\n                params: getParamsForRouteAndAction(newStackAction.routeName, newStackAction)\n              });\n              childState = router.getStateForAction(_childAction3);\n            }\n            return _objectSpread({\n              params: getParamsForRouteAndAction(newStackAction.routeName, newStackAction)\n            }, childState, {\n              routeName: newStackAction.routeName,\n              key: newStackAction.key || generateKey()\n            });\n          }),\n          index: action.index\n        });\n      }\n      if (action.type === NavigationActions.BACK || action.type === StackActions.POP) {\n        var _key = action.key,\n          n = action.n,\n          immediate = action.immediate;\n        var backRouteIndex = state.index;\n        if (action.type === StackActions.POP && n != null) {\n          backRouteIndex = Math.max(1, state.index - n + 1);\n        } else if (_key) {\n          var backRoute = state.routes.find(function (route) {\n            return route.key === _key;\n          });\n          backRouteIndex = state.routes.indexOf(backRoute);\n        }\n        if (backRouteIndex > 0) {\n          return _objectSpread({}, state, {\n            routes: state.routes.slice(0, backRouteIndex),\n            index: backRouteIndex - 1,\n            isTransitioning: immediate !== true\n          });\n        }\n      }\n      var keyIndex = action.key ? StateUtils.indexOf(state, action.key) : -1;\n      for (var _iterator2 = state.routes.slice().reverse(), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"]();;) {\n        var _ref2;\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) break;\n          _ref2 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n          if (_i2.done) break;\n          _ref2 = _i2.value;\n        }\n        var _childRoute3 = _ref2;\n        if (_childRoute3.key === activeChildRoute.key) {\n          continue;\n        }\n        if (keyIndex >= 0 && _childRoute3.key !== action.key) {\n          continue;\n        }\n        var _childRouter5 = childRouters[_childRoute3.routeName];\n        if (_childRouter5) {\n          var _route4 = _childRouter5.getStateForAction(action, _childRoute3);\n          if (_route4 === null) {\n            return state;\n          } else if (_route4 && _route4 !== _childRoute3) {\n            return StateUtils.replaceAt(state, _childRoute3.key, _route4, action.preserveFocus || action.type.includes('DRAWER'));\n          }\n        }\n      }\n      return state;\n    },\n    getPathAndParamsForState: function getPathAndParamsForState(state) {\n      var route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n    getActionForPathAndParams: function getActionForPathAndParams(path, params) {\n      return _getActionForPathAndParams(path, params);\n    },\n    getScreenOptions: createConfigGetter(routeConfigs, stackConfig.defaultNavigationOptions)\n  };\n});","map":{"version":3,"names":["NavigationActions","StackActions","createConfigGetter","getScreenForRouteName","StateUtils","validateRouteConfigMap","invariant","generateKey","createPathParser","behavesLikePushAction","action","type","NAVIGATE","PUSH","defaultActionCreators","isResetToRootStack","RESET","key","routeConfigs","stackConfig","arguments","length","undefined","childRouters","routeNames","Object","keys","forEach","routeName","routeConfig","screen","router","initialRouteParams","getCustomActionCreators","initialRouteName","initialChildRouter","getInitialState","route","childRouter","childState","childAction","init","params","getStateForAction","isTransitioning","index","routes","_objectSpread","navigate","initialRouteKey","getParamsForRouteAndAction","_createPathParser","getPathAndParamsForRoute","_getActionForPathAndParams","getActionForPathAndParams","getComponentForState","state","activeChildRoute","getComponentForRouteName","getActionCreators","navStateKey","pop","n","popToTop","push","replace","replaceWith","newKey","reset","actions","dismiss","back","activeChildRouter","replaceAt","SET_PARAMS","_iterator","slice","reverse","_isArray","Array","isArray","_i","Symbol","iterator","_ref","next","done","value","_childRoute","nextRouteState","newState","replaceAndPrune","immediate","_childRouter","_route","lastRouteIndex","findIndex","r","_route2","_childAction","childRouterNames","i","childRouterName","_childRouter2","initChildRoute","navigatedChildRoute","routeToPush","_route3","POP_TO_TOP","REPLACE","routeIndex","_childRouter3","_childAction2","_routes","_toConsumableArray","COMPLETE_TRANSITION","toChildKey","lastRoute","find","_routes2","indexOf","newStackActions","map","newStackAction","_childAction3","BACK","POP","_key","backRouteIndex","Math","max","backRoute","keyIndex","_iterator2","_isArray2","_i2","_ref2","_childRoute3","_childRouter5","_route4","preserveFocus","includes","getPathAndParamsForState","path","getScreenOptions","defaultNavigationOptions"],"sources":["/Users/zuyax/Developer/rn-starter/node_modules/@react-navigation/core/lib/module/routers/StackRouter.js"],"sourcesContent":["import * as NavigationActions from '../NavigationActions';\nimport * as StackActions from './StackActions';\nimport createConfigGetter from './createConfigGetter';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport StateUtils from '../StateUtils';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport invariant from '../utils/invariant';\nimport { generateKey } from './KeyGenerator';\nimport { createPathParser } from './pathUtils';\n\nfunction behavesLikePushAction(action) {\n  return (\n    action.type === NavigationActions.NAVIGATE ||\n    action.type === StackActions.PUSH\n  );\n}\n\nconst defaultActionCreators = () => ({});\n\nfunction isResetToRootStack(action) {\n  return action.type === StackActions.RESET && action.key === null;\n}\n\nexport default (routeConfigs, stackConfig = {}) => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n\n  const childRouters = {};\n  const routeNames = Object.keys(routeConfigs);\n\n  // Loop through routes and find child routers\n  routeNames.forEach(routeName => {\n    const routeConfig = routeConfigs[routeName];\n    const screen =\n      routeConfig && routeConfig.screen ? routeConfig.screen : routeConfig;\n    if (screen && screen.router) {\n      // If it has a router it's a navigator.\n      childRouters[routeName] = screen.router;\n    } else {\n      // If it doesn't have router it's an ordinary React component.\n      childRouters[routeName] = null;\n    }\n  });\n\n  const { initialRouteParams } = stackConfig;\n  const getCustomActionCreators =\n    stackConfig.getCustomActionCreators || defaultActionCreators;\n\n  const initialRouteName = stackConfig.initialRouteName || routeNames[0];\n\n  const initialChildRouter = childRouters[initialRouteName];\n\n  function getInitialState(action) {\n    let route = {};\n    const childRouter = childRouters[action.routeName];\n\n    // This is a push-like action, and childRouter will be a router or null if we are responsible for this routeName\n    if (behavesLikePushAction(action) && childRouter !== undefined) {\n      let childState = {};\n      // The router is null for normal leaf routes\n      if (childRouter !== null) {\n        const childAction =\n          action.action || NavigationActions.init({ params: action.params });\n        childState = childRouter.getStateForAction(childAction);\n      }\n\n      return {\n        key: 'StackRouterRoot',\n        isTransitioning: false,\n        index: 0,\n        routes: [\n          {\n            params: action.params,\n            ...childState,\n            key: action.key || generateKey(),\n            routeName: action.routeName,\n          },\n        ],\n      };\n    }\n\n    if (initialChildRouter) {\n      route = initialChildRouter.getStateForAction(\n        NavigationActions.navigate({\n          routeName: initialRouteName,\n          params: initialRouteParams,\n        })\n      );\n    }\n    const params = (routeConfigs[initialRouteName].params ||\n      route.params ||\n      action.params ||\n      initialRouteParams) && {\n      ...(routeConfigs[initialRouteName].params || {}),\n      ...(route.params || {}),\n      ...(action.params || {}),\n      ...(initialRouteParams || {}),\n    };\n    const { initialRouteKey } = stackConfig;\n    route = {\n      ...route,\n      ...(params ? { params } : {}),\n      routeName: initialRouteName,\n      key: action.key || (initialRouteKey || generateKey()),\n    };\n    return {\n      key: 'StackRouterRoot',\n      isTransitioning: false,\n      index: 0,\n      routes: [route],\n    };\n  }\n\n  function getParamsForRouteAndAction(routeName, action) {\n    let routeConfig = routeConfigs[routeName];\n    if (routeConfig && routeConfig.params) {\n      return { ...routeConfig.params, ...action.params };\n    } else {\n      return action.params;\n    }\n  }\n\n  const {\n    getPathAndParamsForRoute,\n    getActionForPathAndParams,\n  } = createPathParser(childRouters, routeConfigs, stackConfig);\n\n  return {\n    childRouters,\n\n    getComponentForState(state) {\n      const activeChildRoute = state.routes[state.index];\n      const { routeName } = activeChildRoute;\n      if (childRouters[routeName]) {\n        return childRouters[routeName].getComponentForState(activeChildRoute);\n      }\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getActionCreators(route, navStateKey) {\n      return {\n        ...getCustomActionCreators(route, navStateKey),\n        pop: (n, params) =>\n          StackActions.pop({\n            n,\n            ...params,\n          }),\n        popToTop: params => StackActions.popToTop(params),\n        push: (routeName, params, action) =>\n          StackActions.push({\n            routeName,\n            params,\n            action,\n          }),\n        replace: (replaceWith, params, action, newKey) => {\n          if (typeof replaceWith === 'string') {\n            return StackActions.replace({\n              routeName: replaceWith,\n              params,\n              action,\n              key: route.key,\n              newKey,\n            });\n          }\n          invariant(\n            typeof replaceWith === 'object',\n            'Must replaceWith an object or a string'\n          );\n          invariant(\n            params == null,\n            'Params must not be provided to .replace() when specifying an object'\n          );\n          invariant(\n            action == null,\n            'Child action must not be provided to .replace() when specifying an object'\n          );\n          invariant(\n            newKey == null,\n            'Child action must not be provided to .replace() when specifying an object'\n          );\n          return StackActions.replace(replaceWith);\n        },\n        reset: (actions, index) =>\n          StackActions.reset({\n            actions,\n            index: index == null ? actions.length - 1 : index,\n            key: navStateKey,\n          }),\n        dismiss: () =>\n          NavigationActions.back({\n            key: navStateKey,\n          }),\n      };\n    },\n\n    getStateForAction(action, state) {\n      // Set up the initial state if needed\n      if (!state) {\n        return getInitialState(action);\n      }\n\n      const activeChildRoute = state.routes[state.index];\n\n      if (\n        !isResetToRootStack(action) &&\n        action.type !== NavigationActions.NAVIGATE\n      ) {\n        // Let the active child router handle the action\n        const activeChildRouter = childRouters[activeChildRoute.routeName];\n        if (activeChildRouter) {\n          const route = activeChildRouter.getStateForAction(\n            action,\n            activeChildRoute\n          );\n          if (route !== null && route !== activeChildRoute) {\n            return StateUtils.replaceAt(\n              state,\n              activeChildRoute.key,\n              route,\n              // the following tells replaceAt to NOT change the index to this route for the setParam action, because people don't expect param-setting actions to switch the active route\n              action.type === NavigationActions.SET_PARAMS\n            );\n          }\n        }\n      } else if (action.type === NavigationActions.NAVIGATE) {\n        // Traverse routes from the top of the stack to the bottom, so the\n        // active route has the first opportunity, then the one before it, etc.\n\n        for (let childRoute of state.routes.slice().reverse()) {\n          let childRouter = childRouters[childRoute.routeName];\n          let childAction =\n            action.routeName === childRoute.routeName && action.action\n              ? action.action\n              : action;\n\n          if (childRouter) {\n            const nextRouteState = childRouter.getStateForAction(\n              childAction,\n              childRoute\n            );\n\n            if (nextRouteState === null || nextRouteState !== childRoute) {\n              const newState = StateUtils.replaceAndPrune(\n                state,\n                nextRouteState ? nextRouteState.key : childRoute.key,\n                nextRouteState ? nextRouteState : childRoute\n              );\n              return {\n                ...newState,\n                isTransitioning:\n                  state.index !== newState.index\n                    ? action.immediate !== true\n                    : state.isTransitioning,\n              };\n            }\n          }\n        }\n      }\n\n      // Handle push and navigate actions. This must happen after the focused\n      // child router has had a chance to handle the action.\n      if (\n        behavesLikePushAction(action) &&\n        childRouters[action.routeName] !== undefined // undefined means it's not a childRouter or a screen\n      ) {\n        const childRouter = childRouters[action.routeName];\n        let route;\n\n        invariant(\n          action.type !== StackActions.PUSH || action.key == null,\n          'StackRouter does not support key on the push action'\n        );\n\n        // Before pushing a new route we first try to find one in the existing route stack\n        // More information on this: https://github.com/react-navigation/rfcs/blob/master/text/0004-less-pushy-navigate.md\n        const lastRouteIndex = state.routes.findIndex(r => {\n          if (action.key) {\n            return r.key === action.key;\n          } else {\n            return r.routeName === action.routeName;\n          }\n        });\n\n        // An instance of this route exists already and we're dealing with a navigate action\n        if (action.type !== StackActions.PUSH && lastRouteIndex !== -1) {\n          // If index is unchanged and params are not being set, leave state identity intact\n          if (state.index === lastRouteIndex && !action.params) {\n            return null;\n          }\n\n          // Remove the now unused routes at the tail of the routes array\n          const routes = state.routes.slice(0, lastRouteIndex + 1);\n\n          // Apply params if provided, otherwise leave route identity intact\n          if (action.params) {\n            const route = state.routes[lastRouteIndex];\n            routes[lastRouteIndex] = {\n              ...route,\n              params: {\n                ...route.params,\n                ...action.params,\n              },\n            };\n          }\n          // Return state with new index. Change isTransitioning only if index has changed\n          return {\n            ...state,\n            isTransitioning:\n              state.index !== lastRouteIndex\n                ? action.immediate !== true\n                : state.isTransitioning,\n            index: lastRouteIndex,\n            routes,\n          };\n        }\n\n        if (childRouter) {\n          // Delegate to the child router with the given action, or init it\n          const childAction =\n            action.action ||\n            NavigationActions.init({\n              params: getParamsForRouteAndAction(action.routeName, action),\n            });\n          route = {\n            params: getParamsForRouteAndAction(action.routeName, action),\n            // note(brentvatne): does it make sense to wipe out the params\n            // here? or even to add params at all? need more info about what\n            // this solves\n            ...childRouter.getStateForAction(childAction),\n            routeName: action.routeName,\n            key: action.key || generateKey(),\n          };\n        } else {\n          // Create the route from scratch\n          route = {\n            params: getParamsForRouteAndAction(action.routeName, action),\n            routeName: action.routeName,\n            key: action.key || generateKey(),\n          };\n        }\n        return {\n          ...StateUtils.push(state, route),\n          isTransitioning: action.immediate !== true,\n        };\n      } else if (\n        action.type === StackActions.PUSH &&\n        childRouters[action.routeName] === undefined\n      ) {\n        // Return the state identity to bubble the action up\n        return state;\n      }\n\n      // Handle navigation to other child routers that are not yet pushed\n      if (behavesLikePushAction(action)) {\n        const childRouterNames = Object.keys(childRouters);\n        for (let i = 0; i < childRouterNames.length; i++) {\n          const childRouterName = childRouterNames[i];\n          const childRouter = childRouters[childRouterName];\n          if (childRouter) {\n            // For each child router, start with a blank state\n            const initChildRoute = childRouter.getStateForAction(\n              NavigationActions.init()\n            );\n            // Then check to see if the router handles our navigate action\n            const navigatedChildRoute = childRouter.getStateForAction(\n              action,\n              initChildRoute\n            );\n            let routeToPush = null;\n            if (navigatedChildRoute === null) {\n              // Push the route if the router has 'handled' the action and returned null\n              routeToPush = initChildRoute;\n            } else if (navigatedChildRoute !== initChildRoute) {\n              // Push the route if the state has changed in response to this navigation\n              routeToPush = navigatedChildRoute;\n            }\n            if (routeToPush) {\n              const route = {\n                ...routeToPush,\n                routeName: childRouterName,\n                key: action.key || generateKey(),\n              };\n              return {\n                ...StateUtils.push(state, route),\n                isTransitioning: action.immediate !== true,\n              };\n            }\n          }\n        }\n      }\n\n      // Handle pop-to-top behavior. Make sure this happens after children have had a chance to handle the action, so that the inner stack pops to top first.\n      if (action.type === StackActions.POP_TO_TOP) {\n        // Refuse to handle pop to top if a key is given that doesn't correspond\n        // to this router\n        if (action.key && state.key !== action.key) {\n          return state;\n        }\n\n        // If we're already at the top, then we return the state with a new\n        // identity so that the action is handled by this router.\n        if (state.index > 0) {\n          return {\n            ...state,\n            isTransitioning: action.immediate !== true,\n            index: 0,\n            routes: [state.routes[0]],\n          };\n        }\n        return state;\n      }\n\n      // Handle replace action\n      if (action.type === StackActions.REPLACE) {\n        let routeIndex;\n\n        // If the key param is undefined, set the index to the last route in the stack\n        if (action.key === undefined && state.routes.length) {\n          routeIndex = state.routes.length - 1;\n        } else {\n          routeIndex = state.routes.findIndex(r => r.key === action.key);\n        }\n\n        // Only replace if the key matches one of our routes\n        if (routeIndex !== -1) {\n          const childRouter = childRouters[action.routeName];\n          let childState = {};\n          if (childRouter) {\n            const childAction =\n              action.action ||\n              NavigationActions.init({\n                params: getParamsForRouteAndAction(action.routeName, action),\n              });\n            childState = childRouter.getStateForAction(childAction);\n          }\n          const routes = [...state.routes];\n          routes[routeIndex] = {\n            params: getParamsForRouteAndAction(action.routeName, action),\n            // merge the child state in this order to allow params override\n            ...childState,\n            routeName: action.routeName,\n            key: action.newKey || generateKey(),\n          };\n          return { ...state, routes };\n        }\n      }\n\n      // Update transitioning state\n      if (\n        action.type === StackActions.COMPLETE_TRANSITION &&\n        (action.key == null || action.key === state.key) &&\n        action.toChildKey === state.routes[state.index].key &&\n        state.isTransitioning\n      ) {\n        return {\n          ...state,\n          isTransitioning: false,\n        };\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find(route => route.key === key);\n        if (lastRoute) {\n          const params = {\n            ...lastRoute.params,\n            ...action.params,\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = {\n            ...lastRoute,\n            params,\n          };\n          return {\n            ...state,\n            routes,\n          };\n        }\n      }\n\n      if (action.type === StackActions.RESET) {\n        // Only handle reset actions that are unspecified or match this state key\n        if (action.key != null && action.key != state.key) {\n          // Deliberately use != instead of !== so we can match null with\n          // undefined on either the state or the action\n          return state;\n        }\n        const newStackActions = action.actions;\n\n        return {\n          ...state,\n          routes: newStackActions.map(newStackAction => {\n            const router = childRouters[newStackAction.routeName];\n\n            let childState = {};\n\n            if (router) {\n              const childAction =\n                newStackAction.action ||\n                NavigationActions.init({\n                  params: getParamsForRouteAndAction(\n                    newStackAction.routeName,\n                    newStackAction\n                  ),\n                });\n\n              childState = router.getStateForAction(childAction);\n            }\n\n            return {\n              params: getParamsForRouteAndAction(\n                newStackAction.routeName,\n                newStackAction\n              ),\n              ...childState,\n              routeName: newStackAction.routeName,\n              key: newStackAction.key || generateKey(),\n            };\n          }),\n          index: action.index,\n        };\n      }\n\n      if (\n        action.type === NavigationActions.BACK ||\n        action.type === StackActions.POP\n      ) {\n        const { key, n, immediate } = action;\n        let backRouteIndex = state.index;\n        if (action.type === StackActions.POP && n != null) {\n          // determine the index to go back *from*. In this case, n=1 means to go\n          // back from state.index, as if it were a normal \"BACK\" action\n          backRouteIndex = Math.max(1, state.index - n + 1);\n        } else if (key) {\n          const backRoute = state.routes.find(route => route.key === key);\n          backRouteIndex = state.routes.indexOf(backRoute);\n        }\n\n        if (backRouteIndex > 0) {\n          return {\n            ...state,\n            routes: state.routes.slice(0, backRouteIndex),\n            index: backRouteIndex - 1,\n            isTransitioning: immediate !== true,\n          };\n        }\n      }\n\n      // By this point in the router's state handling logic, we have handled the behavior of the active route, and handled any stack actions.\n      // If we haven't returned by now, we should allow non-active child routers to handle this action, and switch to that index if the child state (route) does change..\n\n      const keyIndex = action.key ? StateUtils.indexOf(state, action.key) : -1;\n\n      // Traverse routes from the top of the stack to the bottom, so the\n      // active route has the first opportunity, then the one before it, etc.\n      for (let childRoute of state.routes.slice().reverse()) {\n        if (childRoute.key === activeChildRoute.key) {\n          // skip over the active child because we let it attempt to handle the action earlier\n          continue;\n        }\n        // If a key is provided and in routes state then let's use that\n        // knowledge to skip extra getStateForAction calls on other child\n        // routers\n        if (keyIndex >= 0 && childRoute.key !== action.key) {\n          continue;\n        }\n        let childRouter = childRouters[childRoute.routeName];\n        if (childRouter) {\n          const route = childRouter.getStateForAction(action, childRoute);\n\n          if (route === null) {\n            return state;\n          } else if (route && route !== childRoute) {\n            return StateUtils.replaceAt(\n              state,\n              childRoute.key,\n              route,\n              // People don't expect these actions to switch the active route\n              // TODO: We should switch to action.preserveFocus: true for drawer in future\n              action.preserveFocus || action.type.includes('DRAWER')\n            );\n          }\n        }\n      }\n\n      return state;\n    },\n\n    getPathAndParamsForState(state) {\n      const route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n\n    getActionForPathAndParams(path, params) {\n      return getActionForPathAndParams(path, params);\n    },\n\n    getScreenOptions: createConfigGetter(\n      routeConfigs,\n      stackConfig.defaultNavigationOptions\n    ),\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}