{"ast":null,"code":"function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport Constants from 'expo-constants';\nimport { EventEmitter } from 'fbemitter';\nimport invariant from 'invariant';\nimport AsyncStorage from \"react-native-web/dist/exports/AsyncStorage\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport DeviceEventEmitter from 'react-native/Libraries/EventEmitter/RCTDeviceEventEmitter';\nimport ExponentNotifications from \"./ExponentNotifications\";\nvar _emitter;\nvar _initialNotification;\nfunction _maybeInitEmitter() {\n  if (!_emitter) {\n    _emitter = new EventEmitter();\n    DeviceEventEmitter.addListener('Exponent.notification', _emitNotification);\n  }\n}\nfunction _emitNotification(notification) {\n  if (typeof notification === 'string') {\n    notification = JSON.parse(notification);\n  }\n  notification = _objectSpread({}, notification);\n  if (typeof notification.data === 'string') {\n    try {\n      notification.data = JSON.parse(notification.data);\n    } catch (e) {}\n  }\n  _emitter.emit('notification', notification);\n}\nfunction _processNotification(notification) {\n  notification = _extends({}, notification);\n  if (!notification.data) {\n    notification.data = {};\n  }\n  if (notification.hasOwnProperty('count')) {\n    delete notification.count;\n  }\n  if (Platform.OS === 'ios') {\n    if (notification.android) {\n      delete notification.android;\n    }\n    if (notification.ios) {\n      notification = _extends(notification, notification.ios);\n      delete notification.ios;\n    }\n  }\n  if (Platform.OS === 'android') {\n    if (notification.ios) {\n      delete notification.ios;\n    }\n    if (notification.android) {\n      notification = _extends(notification, notification.android);\n      delete notification.android;\n    }\n  }\n  return notification;\n}\nfunction _validateNotification(notification) {\n  if (Platform.OS === 'ios') {\n    invariant(!!notification.title && !!notification.body, 'Local notifications on iOS require both a title and a body');\n  } else if (Platform.OS === 'android') {\n    invariant(!!notification.title, 'Local notifications on Android require a title');\n  }\n}\nvar ASYNC_STORAGE_PREFIX = '__expo_internal_channel_';\nvar IS_USING_NEW_BINARY = typeof ExponentNotifications.createChannel === 'function';\nfunction _legacyReadChannel(_x) {\n  return _legacyReadChannel2.apply(this, arguments);\n}\nfunction _legacyReadChannel2() {\n  _legacyReadChannel2 = _asyncToGenerator(function* (id) {\n    try {\n      var channelString = yield AsyncStorage.getItem(\"\".concat(ASYNC_STORAGE_PREFIX).concat(id));\n      if (channelString) {\n        return JSON.parse(channelString);\n      }\n    } catch (e) {}\n    return null;\n  });\n  return _legacyReadChannel2.apply(this, arguments);\n}\nfunction _legacyDeleteChannel(id) {\n  return AsyncStorage.removeItem(\"\".concat(ASYNC_STORAGE_PREFIX).concat(id));\n}\nif (Platform.OS === 'android') {\n  AsyncStorage.clear = function () {\n    var _ref = _asyncToGenerator(function* (callback) {\n      try {\n        var keys = yield AsyncStorage.getAllKeys();\n        var result = null;\n        if (keys && keys.length) {\n          var filteredKeys = keys.filter(key => !key.startsWith(ASYNC_STORAGE_PREFIX));\n          yield AsyncStorage.multiRemove(filteredKeys);\n        }\n        callback && callback();\n      } catch (e) {\n        callback && callback(e);\n        throw e;\n      }\n    });\n    return function (_x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}\nfunction _legacySaveChannel(id, channel) {\n  return AsyncStorage.setItem(\"\".concat(ASYNC_STORAGE_PREFIX).concat(id), JSON.stringify(channel));\n}\nexport default {\n  _setInitialNotification(notification) {\n    _initialNotification = notification;\n  },\n  createCategoryAsync(categoryId, actions) {\n    return ExponentNotifications.createCategoryAsync(categoryId, actions);\n  },\n  deleteCategoryAsync(categoryId) {\n    return ExponentNotifications.deleteCategoryAsync(categoryId);\n  },\n  getExpoPushTokenAsync() {\n    if (!Constants.isDevice) {\n      throw new Error(\"Must be on a physical device to get an Expo Push Token\");\n    }\n    return ExponentNotifications.getExponentPushTokenAsync();\n  },\n  getDevicePushTokenAsync: config => ExponentNotifications.getDevicePushTokenAsync(config || {}),\n  createChannelAndroidAsync(id, channel) {\n    if (Platform.OS !== 'android') {\n      console.warn(\"createChannelAndroidAsync(...) has no effect on \".concat(Platform.OS));\n      return Promise.resolve();\n    }\n    if (!IS_USING_NEW_BINARY) {\n      return _legacySaveChannel(id, channel);\n    }\n    return ExponentNotifications.createChannel(id, channel);\n  },\n  deleteChannelAndroidAsync(id) {\n    if (Platform.OS === 'ios') {\n      console.warn('deleteChannelAndroidAsync(...) has no effect on iOS');\n      return Promise.resolve();\n    }\n    if (!IS_USING_NEW_BINARY) {\n      return Promise.resolve();\n    }\n    return ExponentNotifications.deleteChannel(id);\n  },\n  presentLocalNotificationAsync(notification) {\n    return _asyncToGenerator(function* () {\n      _validateNotification(notification);\n      var nativeNotification = _processNotification(notification);\n      if (Platform.OS === 'ios') {\n        return ExponentNotifications.presentLocalNotification(nativeNotification);\n      } else {\n        var _channel;\n        if (nativeNotification.channelId) {\n          _channel = yield _legacyReadChannel(nativeNotification.channelId);\n        }\n        if (IS_USING_NEW_BINARY) {\n          _legacyDeleteChannel(nativeNotification.channelId);\n          return ExponentNotifications.presentLocalNotificationWithChannel(nativeNotification, _channel);\n        } else {\n          if (_channel) {\n            nativeNotification.sound = _channel.sound;\n            nativeNotification.priority = _channel.priority;\n            nativeNotification.vibrate = _channel.vibrate;\n          }\n          return ExponentNotifications.presentLocalNotification(nativeNotification);\n        }\n      }\n    })();\n  },\n  scheduleLocalNotificationAsync(notification) {\n    var _arguments = arguments;\n    return _asyncToGenerator(function* () {\n      var options = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : {};\n      var now = Date.now();\n      _validateNotification(notification);\n      var nativeNotification = _processNotification(notification);\n      if (options.time) {\n        var timeAsDateObj = null;\n        if (options.time && typeof options.time === 'number') {\n          timeAsDateObj = new Date(options.time);\n          if (timeAsDateObj.toString() === 'Invalid Date') {\n            timeAsDateObj = null;\n          }\n        } else if (options.time && options.time instanceof Date) {\n          timeAsDateObj = options.time;\n        }\n        if (!timeAsDateObj) {\n          throw new Error(\"Provided value for \\\"time\\\" is invalid. Please verify that it's either a number representing Unix Epoch time in milliseconds, or a valid date object.\");\n        }\n        if (timeAsDateObj.getTime() < now) {\n          console.warn(\"Provided value for \\\"time\\\" is before the current date. Did you possibly pass number of seconds since Unix Epoch instead of number of milliseconds?\");\n        }\n        options = _objectSpread({}, options, {\n          time: timeAsDateObj.getTime()\n        });\n      }\n      if (options.intervalMs != null && options.repeat != null) {\n        throw new Error(\"Pass either the \\\"repeat\\\" option or \\\"intervalMs\\\" option, not both\");\n      }\n      if (options.repeat != null) {\n        var validOptions = new Set(['minute', 'hour', 'day', 'week', 'month', 'year']);\n        if (!validOptions.has(options.repeat)) {\n          throw new Error(\"Pass one of ['minute', 'hour', 'day', 'week', 'month', 'year'] as the value for the \\\"repeat\\\" option\");\n        }\n      }\n      if (options.intervalMs != null) {\n        if (Platform.OS === 'ios') {\n          throw new Error(\"The \\\"intervalMs\\\" option is not supported on iOS\");\n        }\n        if (options.intervalMs <= 0 || !Number.isInteger(options.intervalMs)) {\n          throw new Error(\"Pass an integer greater than zero as the value for the \\\"intervalMs\\\" option\");\n        }\n      }\n      if (Platform.OS === 'ios') {\n        if (options.repeat) {\n          console.warn('Ability to schedule an automatically repeated notification is deprecated on iOS and will be removed in the next SDK release.');\n          return ExponentNotifications.legacyScheduleLocalRepeatingNotification(nativeNotification, options);\n        }\n        return ExponentNotifications.scheduleLocalNotification(nativeNotification, options);\n      } else {\n        var _channel;\n        if (nativeNotification.channelId) {\n          _channel = yield _legacyReadChannel(nativeNotification.channelId);\n        }\n        if (IS_USING_NEW_BINARY) {\n          _legacyDeleteChannel(nativeNotification.channelId);\n          return ExponentNotifications.scheduleLocalNotificationWithChannel(nativeNotification, options, _channel);\n        } else {\n          if (_channel) {\n            nativeNotification.sound = _channel.sound;\n            nativeNotification.priority = _channel.priority;\n            nativeNotification.vibrate = _channel.vibrate;\n          }\n          return ExponentNotifications.scheduleLocalNotification(nativeNotification, options);\n        }\n      }\n    })();\n  },\n  dismissNotificationAsync(notificationId) {\n    return _asyncToGenerator(function* () {\n      if (Platform.OS === 'android') {\n        return ExponentNotifications.dismissNotification(notificationId);\n      } else {\n        throw new Error('Dismissing notifications is not supported on iOS');\n      }\n    })();\n  },\n  dismissAllNotificationsAsync() {\n    return _asyncToGenerator(function* () {\n      if (Platform.OS === 'android') {\n        return ExponentNotifications.dismissAllNotifications();\n      } else {\n        throw new Error('Dismissing notifications is not supported on iOS');\n      }\n    })();\n  },\n  cancelScheduledNotificationAsync(notificationId) {\n    return ExponentNotifications.cancelScheduledNotificationAsync(notificationId);\n  },\n  cancelAllScheduledNotificationsAsync() {\n    return ExponentNotifications.cancelAllScheduledNotificationsAsync();\n  },\n  addListener(listener) {\n    _maybeInitEmitter();\n    if (_initialNotification) {\n      var initialNotification = _initialNotification;\n      _initialNotification = null;\n      setTimeout(() => {\n        _emitNotification(initialNotification);\n      }, 0);\n    }\n    return _emitter.addListener('notification', listener);\n  },\n  getBadgeNumberAsync() {\n    return _asyncToGenerator(function* () {\n      if (!ExponentNotifications.getBadgeNumberAsync) {\n        return 0;\n      }\n      return ExponentNotifications.getBadgeNumberAsync();\n    })();\n  },\n  setBadgeNumberAsync(number) {\n    return _asyncToGenerator(function* () {\n      if (!ExponentNotifications.setBadgeNumberAsync) {\n        return;\n      }\n      return ExponentNotifications.setBadgeNumberAsync(number);\n    })();\n  }\n};","map":{"version":3,"names":["Constants","EventEmitter","invariant","AsyncStorage","Platform","DeviceEventEmitter","ExponentNotifications","_emitter","_initialNotification","_maybeInitEmitter","addListener","_emitNotification","notification","JSON","parse","_objectSpread","data","e","emit","_processNotification","_extends","hasOwnProperty","count","OS","android","ios","_validateNotification","title","body","ASYNC_STORAGE_PREFIX","IS_USING_NEW_BINARY","createChannel","_legacyReadChannel","_x","_legacyReadChannel2","apply","arguments","_asyncToGenerator","id","channelString","getItem","concat","_legacyDeleteChannel","removeItem","clear","_ref","callback","keys","getAllKeys","result","length","filteredKeys","filter","key","startsWith","multiRemove","_x2","_legacySaveChannel","channel","setItem","stringify","_setInitialNotification","createCategoryAsync","categoryId","actions","deleteCategoryAsync","getExpoPushTokenAsync","isDevice","Error","getExponentPushTokenAsync","getDevicePushTokenAsync","config","createChannelAndroidAsync","console","warn","Promise","resolve","deleteChannelAndroidAsync","deleteChannel","presentLocalNotificationAsync","nativeNotification","presentLocalNotification","_channel","channelId","presentLocalNotificationWithChannel","sound","priority","vibrate","scheduleLocalNotificationAsync","_arguments","options","undefined","now","Date","time","timeAsDateObj","toString","getTime","intervalMs","repeat","validOptions","Set","has","Number","isInteger","legacyScheduleLocalRepeatingNotification","scheduleLocalNotification","scheduleLocalNotificationWithChannel","dismissNotificationAsync","notificationId","dismissNotification","dismissAllNotificationsAsync","dismissAllNotifications","cancelScheduledNotificationAsync","cancelAllScheduledNotificationsAsync","listener","initialNotification","setTimeout","getBadgeNumberAsync","setBadgeNumberAsync","number"],"sources":["/Users/zuyax/Developer/rn-starter/node_modules/expo/src/Notifications/Notifications.ts"],"sourcesContent":["import Constants from 'expo-constants';\nimport { EventEmitter, EventSubscription } from 'fbemitter';\nimport invariant from 'invariant';\nimport { AsyncStorage, Platform } from 'react-native';\nimport DeviceEventEmitter from 'react-native/Libraries/EventEmitter/RCTDeviceEventEmitter';\nimport ExponentNotifications from './ExponentNotifications';\n\ntype Notification = {\n  origin: 'selected' | 'received';\n  data: any;\n  remote: boolean;\n  isMultiple: boolean;\n};\n\ntype LocalNotification = {\n  title: string;\n  // How should we deal with body being required on iOS but not on Android?\n  body?: string;\n  data?: any;\n  categoryId?: string;\n  ios?: {\n    sound?: boolean;\n  };\n  android?: {\n    channelId?: string;\n    icon?: string;\n    color?: string;\n    sticky?: boolean;\n    link?: string;\n  };\n};\n\ntype Channel = {\n  name: string;\n  description?: string;\n  priority?: string;\n  sound?: boolean;\n  vibrate?: boolean | number[];\n  badge?: boolean;\n};\n\ntype ActionType = {\n  actionId: string;\n  buttonTitle: string;\n  isDestructive?: boolean;\n  isAuthenticationRequired?: boolean;\n  textInput?: {\n    submitButtonTitle: string;\n    placeholder: string;\n  };\n};\n\n// Android assigns unique number to each notification natively.\n// Since that's not supported on iOS, we generate an unique string.\ntype LocalNotificationId = string | number;\n\nlet _emitter;\nlet _initialNotification;\n\nfunction _maybeInitEmitter() {\n  if (!_emitter) {\n    _emitter = new EventEmitter();\n    DeviceEventEmitter.addListener('Exponent.notification', _emitNotification);\n  }\n}\n\nfunction _emitNotification(notification) {\n  if (typeof notification === 'string') {\n    notification = JSON.parse(notification);\n  }\n\n  /* Don't mutate the original notification */\n  notification = { ...notification };\n\n  if (typeof notification.data === 'string') {\n    try {\n      notification.data = JSON.parse(notification.data);\n    } catch (e) {\n      // It's actually just a string, that's fine\n    }\n  }\n\n  _emitter.emit('notification', notification);\n}\n\nfunction _processNotification(notification) {\n  notification = Object.assign({}, notification);\n\n  if (!notification.data) {\n    notification.data = {};\n  }\n\n  if (notification.hasOwnProperty('count')) {\n    delete notification.count;\n  }\n\n  // Delete any Android properties on iOS and merge the iOS properties on root notification object\n  if (Platform.OS === 'ios') {\n    if (notification.android) {\n      delete notification.android;\n    }\n\n    if (notification.ios) {\n      notification = Object.assign(notification, notification.ios);\n      delete notification.ios;\n    }\n  }\n\n  // Delete any iOS properties on Android and merge the Android properties on root notification\n  // object\n  if (Platform.OS === 'android') {\n    if (notification.ios) {\n      delete notification.ios;\n    }\n\n    if (notification.android) {\n      notification = Object.assign(notification, notification.android);\n      delete notification.android;\n    }\n  }\n\n  return notification;\n}\n\nfunction _validateNotification(notification) {\n  if (Platform.OS === 'ios') {\n    invariant(\n      !!notification.title && !!notification.body,\n      'Local notifications on iOS require both a title and a body'\n    );\n  } else if (Platform.OS === 'android') {\n    invariant(!!notification.title, 'Local notifications on Android require a title');\n  }\n}\n\nlet ASYNC_STORAGE_PREFIX = '__expo_internal_channel_';\n// TODO: remove this before releasing\n// this will always be `true` for SDK 28+\nlet IS_USING_NEW_BINARY = typeof ExponentNotifications.createChannel === 'function';\n\nasync function _legacyReadChannel(id: string): Promise<Channel | null> {\n  try {\n    let channelString = await AsyncStorage.getItem(`${ASYNC_STORAGE_PREFIX}${id}`);\n    if (channelString) {\n      return JSON.parse(channelString);\n    }\n  } catch (e) {}\n  return null;\n}\n\nfunction _legacyDeleteChannel(id: string): Promise<void> {\n  return AsyncStorage.removeItem(`${ASYNC_STORAGE_PREFIX}${id}`);\n}\n\nif (Platform.OS === 'android') {\n  AsyncStorage.clear = async function(callback?: (error?: Error) => void): Promise<void> {\n    try {\n      let keys = await AsyncStorage.getAllKeys();\n      let result = null;\n      if (keys && keys.length) {\n        let filteredKeys = keys.filter(key => !key.startsWith(ASYNC_STORAGE_PREFIX));\n        await AsyncStorage.multiRemove(filteredKeys);\n      }\n      callback && callback();\n    } catch (e) {\n      callback && callback(e);\n      throw e;\n    }\n  };\n}\n\n// This codepath will never be triggered in SDK 28 and above\n// TODO: remove before releasing\nfunction _legacySaveChannel(id: string, channel: Channel): Promise<void> {\n  return AsyncStorage.setItem(`${ASYNC_STORAGE_PREFIX}${id}`, JSON.stringify(channel));\n}\n\nexport default {\n  /* Only used internally to initialize the notification from top level props */\n  _setInitialNotification(notification: Notification) {\n    _initialNotification = notification;\n  },\n\n  // User passes set of actions titles.\n  createCategoryAsync(categoryId: string, actions: ActionType[]): Promise<void> {\n    return ExponentNotifications.createCategoryAsync(categoryId, actions);\n  },\n\n  deleteCategoryAsync(categoryId: string): Promise<void> {\n    return ExponentNotifications.deleteCategoryAsync(categoryId);\n  },\n\n  /* Re-export */\n  getExpoPushTokenAsync(): Promise<string> {\n    if (!Constants.isDevice) {\n      throw new Error(`Must be on a physical device to get an Expo Push Token`);\n    }\n    return ExponentNotifications.getExponentPushTokenAsync();\n  },\n\n  getDevicePushTokenAsync: (config: {\n    gcmSenderId?: string;\n  }): Promise<{ type: string; data: string }> =>\n    ExponentNotifications.getDevicePushTokenAsync(config || {}),\n\n  createChannelAndroidAsync(id: string, channel: Channel): Promise<void> {\n    if (Platform.OS !== 'android') {\n      console.warn(`createChannelAndroidAsync(...) has no effect on ${Platform.OS}`);\n      return Promise.resolve();\n    }\n    // This codepath will never be triggered in SDK 28 and above\n    // TODO: remove before releasing\n    if (!IS_USING_NEW_BINARY) {\n      return _legacySaveChannel(id, channel);\n    }\n    return ExponentNotifications.createChannel(id, channel);\n  },\n\n  deleteChannelAndroidAsync(id: string): Promise<void> {\n    if (Platform.OS === 'ios') {\n      console.warn('deleteChannelAndroidAsync(...) has no effect on iOS');\n      return Promise.resolve();\n    }\n    // This codepath will never be triggered in SDK 28 and above\n    // TODO: remove before releasing\n    if (!IS_USING_NEW_BINARY) {\n      return Promise.resolve();\n    }\n    return ExponentNotifications.deleteChannel(id);\n  },\n\n  /* Shows a notification instantly */\n  async presentLocalNotificationAsync(\n    notification: LocalNotification\n  ): Promise<LocalNotificationId> {\n    _validateNotification(notification);\n    let nativeNotification = _processNotification(notification);\n\n    if (Platform.OS === 'ios') {\n      return ExponentNotifications.presentLocalNotification(nativeNotification);\n    } else {\n      let _channel;\n      if (nativeNotification.channelId) {\n        _channel = await _legacyReadChannel(nativeNotification.channelId);\n      }\n\n      if (IS_USING_NEW_BINARY) {\n        // delete the legacy channel from AsyncStorage so this codepath isn't triggered anymore\n        _legacyDeleteChannel(nativeNotification.channelId);\n        return ExponentNotifications.presentLocalNotificationWithChannel(\n          nativeNotification,\n          _channel\n        );\n      } else {\n        // TODO: remove this codepath before releasing, it will never be triggered on SDK 28+\n        // channel does not actually exist, so add its settings to the individual notification\n        if (_channel) {\n          nativeNotification.sound = _channel.sound;\n          nativeNotification.priority = _channel.priority;\n          nativeNotification.vibrate = _channel.vibrate;\n        }\n        return ExponentNotifications.presentLocalNotification(nativeNotification);\n      }\n    }\n  },\n\n  /* Schedule a notification at a later date */\n  async scheduleLocalNotificationAsync(\n    notification: LocalNotification,\n    options: {\n      time?: Date | number;\n      repeat?: 'minute' | 'hour' | 'day' | 'week' | 'month' | 'year';\n      intervalMs?: number;\n    } = {}\n  ): Promise<LocalNotificationId> {\n    // set now at the beginning of the method, to prevent potential weird warnings when we validate\n    // options.time later on\n    const now = Date.now();\n\n    // Validate and process the notification data\n    _validateNotification(notification);\n    let nativeNotification = _processNotification(notification);\n\n    // Validate `options.time`\n    if (options.time) {\n      let timeAsDateObj: Date | null = null;\n      if (options.time && typeof options.time === 'number') {\n        timeAsDateObj = new Date(options.time);\n        if (timeAsDateObj.toString() === 'Invalid Date') {\n          timeAsDateObj = null;\n        }\n      } else if (options.time && options.time instanceof Date) {\n        timeAsDateObj = options.time;\n      }\n\n      // If we couldn't convert properly, throw an error\n      if (!timeAsDateObj) {\n        throw new Error(\n          `Provided value for \"time\" is invalid. Please verify that it's either a number representing Unix Epoch time in milliseconds, or a valid date object.`\n        );\n      }\n\n      // If someone passes in a value that is too small, say, by an order of 1000 (it's common to\n      // accidently pass seconds instead of ms), display a warning.\n      if (timeAsDateObj.getTime() < now) {\n        console.warn(\n          `Provided value for \"time\" is before the current date. Did you possibly pass number of seconds since Unix Epoch instead of number of milliseconds?`\n        );\n      }\n\n      options = {\n        ...options,\n        time: timeAsDateObj.getTime(),\n      };\n    }\n\n    if (options.intervalMs != null && options.repeat != null) {\n      throw new Error(`Pass either the \"repeat\" option or \"intervalMs\" option, not both`);\n    }\n\n    // Validate options.repeat\n    if (options.repeat != null) {\n      const validOptions = new Set(['minute', 'hour', 'day', 'week', 'month', 'year']);\n      if (!validOptions.has(options.repeat)) {\n        throw new Error(\n          `Pass one of ['minute', 'hour', 'day', 'week', 'month', 'year'] as the value for the \"repeat\" option`\n        );\n      }\n    }\n\n    if (options.intervalMs != null) {\n      if (Platform.OS === 'ios') {\n        throw new Error(`The \"intervalMs\" option is not supported on iOS`);\n      }\n\n      if (options.intervalMs <= 0 || !Number.isInteger(options.intervalMs)) {\n        throw new Error(\n          `Pass an integer greater than zero as the value for the \"intervalMs\" option`\n        );\n      }\n    }\n\n    if (Platform.OS === 'ios') {\n      if (options.repeat) {\n        console.warn('Ability to schedule an automatically repeated notification is deprecated on iOS and will be removed in the next SDK release.');\n        return ExponentNotifications.legacyScheduleLocalRepeatingNotification(nativeNotification, options);\n      }\n\n      return ExponentNotifications.scheduleLocalNotification(nativeNotification, options);\n    } else {\n      let _channel;\n      if (nativeNotification.channelId) {\n        _channel = await _legacyReadChannel(nativeNotification.channelId);\n      }\n\n      if (IS_USING_NEW_BINARY) {\n        // delete the legacy channel from AsyncStorage so this codepath isn't triggered anymore\n        _legacyDeleteChannel(nativeNotification.channelId);\n        return ExponentNotifications.scheduleLocalNotificationWithChannel(\n          nativeNotification,\n          options,\n          _channel\n        );\n      } else {\n        // TODO: remove this codepath before releasing, it will never be triggered on SDK 28+\n        // channel does not actually exist, so add its settings to the individual notification\n        if (_channel) {\n          nativeNotification.sound = _channel.sound;\n          nativeNotification.priority = _channel.priority;\n          nativeNotification.vibrate = _channel.vibrate;\n        }\n        return ExponentNotifications.scheduleLocalNotification(nativeNotification, options);\n      }\n    }\n  },\n\n  /* Dismiss currently shown notification with ID (Android only) */\n  async dismissNotificationAsync(notificationId: LocalNotificationId): Promise<void> {\n    if (Platform.OS === 'android') {\n      return ExponentNotifications.dismissNotification(notificationId);\n    } else {\n      throw new Error('Dismissing notifications is not supported on iOS');\n    }\n  },\n\n  /* Dismiss all currently shown notifications (Android only) */\n  async dismissAllNotificationsAsync(): Promise<void> {\n    if (Platform.OS === 'android') {\n      return ExponentNotifications.dismissAllNotifications();\n    } else {\n      throw new Error('Dismissing notifications is not supported on iOS');\n    }\n  },\n\n  /* Cancel scheduled notification notification with ID */\n  cancelScheduledNotificationAsync(notificationId: LocalNotificationId): Promise<void> {\n    return ExponentNotifications.cancelScheduledNotificationAsync(notificationId);\n  },\n\n  /* Cancel all scheduled notifications */\n  cancelAllScheduledNotificationsAsync(): Promise<void> {\n    return ExponentNotifications.cancelAllScheduledNotificationsAsync();\n  },\n\n  /* Primary public api */\n  addListener(listener: Function): EventSubscription {\n    _maybeInitEmitter();\n\n    if (_initialNotification) {\n      const initialNotification = _initialNotification;\n      _initialNotification = null;\n      setTimeout(() => {\n        _emitNotification(initialNotification);\n      }, 0);\n    }\n\n    return _emitter.addListener('notification', listener);\n  },\n\n  async getBadgeNumberAsync(): Promise<number> {\n    if (!ExponentNotifications.getBadgeNumberAsync) {\n      return 0;\n    }\n    return ExponentNotifications.getBadgeNumberAsync();\n  },\n\n  async setBadgeNumberAsync(number: number): Promise<void> {\n    if (!ExponentNotifications.setBadgeNumberAsync) {\n      return;\n    }\n    return ExponentNotifications.setBadgeNumberAsync(number);\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}